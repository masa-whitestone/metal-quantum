{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Metal-Q \u269b\ufe0f\ud83c\udf4e","text":"<p>A high-performance quantum circuit optimization and simulation library for Apple Silicon, leveraging Metal GPU acceleration.</p> <p> </p> <p>Metal-Q is a comprehensive quantum computing library designed specifically for Apple Silicon (M1/M2/M3/M4) devices. Unlike standard simulators, Metal-Q includes a fully differentiable backend (supporting Adjoint Differentiation on GPU) and seamless integration with PyTorch, making it ideal for Quantum Machine Learning (QML) and Variational Algorithms (VQE/QAOA).</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>GPU Acceleration: Up to 50x faster than standard CPU simulators for statevector simulation using Metal Compute Shaders.</li> <li>Adjoint Differentiation: Native GPU implementation of Adjoint Differentiation, enabling gradient calculation with O(1) memory cost relative to circuit depth.</li> <li>PyTorch Integration: Built-in autograd functions allow Metal-Q circuits to act as standard PyTorch layers.</li> <li>Algorithms: Ready-to-use implementations of VQE (Variational Quantum Eigensolver) and QAOA.</li> <li>Qiskit Compatibility: Includes a bidirectional adapter to convert circuits to/from Qiskit <code>QuantumCircuit</code>.</li> <li>Rich Visualization: Improved terminal-based circuit visualization with Unicode support.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install metalq\n</code></pre> <p>See Installation for more details.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Here is a simple example of creating a Bell State using Metal-Q.</p> <pre><code>from metalq import Circuit, run\n\n# 1. Create a Circuit\nqc = Circuit(2)\nqc.h(0)\nqc.cx(0, 1)\n\n# 2. Visualize\nprint(qc)\n</code></pre> <p>Output: <pre><code>     \u256d\u2500\u256e   \nq_0: \u2502H\u2502\u2500\u25cf\u2500\n     \u2570\u2500\u256f \u2502 \n        \u256d\u2534\u256e\nq_1: \u2500\u2500\u2500\u2502X\u2502\n        \u2570\u2500\u256f\n</code></pre></p> <pre><code># 3. Run on Metal GPU (MPS)\nresult = run(qc, shots=1000)\nprint(f\"Counts: {result.counts}\")\n</code></pre> <p>Output: <pre><code>Counts: {'11': 502, '00': 498}\n</code></pre></p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>User Guide: Learn the basics of circuit construction and execution.</li> <li>PyTorch Integration: Train hybrid quantum-classical models.</li> <li>Algorithms: Run VQE and QAOA.</li> <li>API Reference: Detailed API documentation.</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License. See LICENSE for details.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>Metal-Q is built with a layered architecture to maximize performance while maintaining ease of use:</p> <ol> <li>Python API: High-level interface (<code>metalq</code>) and PyTorch bindings.</li> <li>C Interface: Lightweight Ctypes bridge (<code>native/include/metalq.h</code>).</li> <li>Objective-C Native Layer: Manages Metal context (<code>MTLDevice</code>, <code>MTLCommandQueue</code>) and buffers.</li> <li>Metal Compute Shaders: Optimized GPU kernels written in Metal Shading Language (MSL).</li> </ol>"},{"location":"architecture/#components","title":"Components","text":"<pre><code>graph TD\n    A[User Code] --&gt; B[metalq (Python)]\n    B --&gt; C[metalq.backend.mps]\n    C --&gt; D[libmetalq.dylib (C/Obj-C)]\n    D --&gt; E[Metal API]\n    E --&gt; F[GPU Compute Shaders]\n\n    B --&gt; G[PyTorch Integration]\n    G -.-&gt; H[Autograd]\n    G --&gt; B\n</code></pre>"},{"location":"architecture/#gate-execution-flow","title":"Gate Execution Flow","text":"<ol> <li>User defines <code>Circuit</code>.</li> <li><code>run(circuit)</code> is called.</li> <li>Backend converts gate list to C structs (<code>mq_gate_t</code>).</li> <li><code>metalq_run</code> is invoked via ctypes.</li> <li>Native layer uploads state vector and gate parameters to GPU buffers.</li> <li>Compute shaders apply gates in parallel (one thread per amplitude pair).</li> <li>Results are downloaded back to CPU (if needed).</li> </ol>"},{"location":"benchmarks/","title":"Performance Benchmarks","text":"<p>Benchmarks on Apple M3 Pro (36GB RAM) demonstrate significant performance improvements over CPU-based simulators. Metal-Q excels particularly with larger qubit counts and deep circuits such as Quantum Fourier Transform (QFT).</p> <p>Note</p> <p>Benchmarks run on Apple M3 Pro (36GB RAM). Metal-Q uses half-precision complex numbers (MPS limit), while Qiskit uses double precision.</p>"},{"location":"benchmarks/#statevector-simulation","title":"Statevector Simulation","text":"<p>Random circuit simulation performance:</p> Qubits Depth Metal-Q Qiskit Speedup 16 10 2ms 43ms 17.9x 20 10 20ms 1025ms 50.2x 22 10 217ms 4976ms 22.9x 24 8 775ms 16999ms 21.9x 26 6 2510ms 54967ms 21.9x"},{"location":"benchmarks/#quantum-fourier-transform-qft","title":"Quantum Fourier Transform (QFT)","text":"Qubits Metal-Q Qiskit Speedup 16 1ms 24ms 18.6x 20 14ms 664ms 47.9x 22 137ms 3284ms 23.9x 24 643ms 14932ms 23.2x"},{"location":"benchmarks/#sampling","title":"Sampling","text":"<p>Measurements with 8192 shots:</p> Qubits Metal-Q Qiskit Aer Speedup 16 9ms 16ms 1.9x 20 34ms 143ms 4.2x 22 273ms 511ms 1.9x 24 974ms 1540ms 1.6x"},{"location":"benchmarks/#cpu-vs-aer","title":"CPU vs Aer","text":"<p>For smaller systems where GPU overhead dominates, Metal-Q includes an optimized CPU backend with Numba:</p> Qubits Metal-Q CPU Qiskit Aer Comparison 10 3ms 1ms Aer faster 14 3ms 4ms 1.31x faster 16 13ms 12ms Comparable"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>OS: macOS 12.0+ (Monterey or later)</li> <li>Hardware: Apple Silicon (M1/M2/M3/M4) Mac</li> <li>Python: 3.10+</li> <li>Tools: Xcode Command Line Tools (for native compilation)</li> </ul>"},{"location":"installation/#install-from-pypi","title":"Install from PyPI","text":"<p>The easiest way to install Metal-Q is via pip:</p> <pre><code>pip install metalq\n</code></pre>"},{"location":"installation/#install-from-source","title":"Install from Source","text":"<p>For development or to get the latest features, you can install from source:</p> <ol> <li> <p>Clone the repository:     <pre><code>git clone https://github.com/masa-whitestone/metal-quantum.git\ncd metal-quantum\n</code></pre></p> </li> <li> <p>Compile the native Metal library:     <pre><code>cd native &amp;&amp; make &amp;&amp; cd ..\n</code></pre></p> </li> <li> <p>Install the Python package:     <pre><code>pip install -e .\n</code></pre></p> </li> </ol>"},{"location":"installation/#verification","title":"Verification","text":"<p>To verify the installation, run a simple Python script:</p> <pre><code>from metalq import Circuit, run\n\n# Create a small circuit\nqc = Circuit(2)\nqc.h(0)\nqc.cx(0, 1)\n\n# Run on MPS backend\nresult = run(qc, shots=100)\nprint(result.counts)\n</code></pre> <p>If you see output like <code>{'00': 48, '11': 52}</code>, the installation was successful!</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2025 Masaki Shiraishi</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"api/","title":"API Reference","text":"<p>Top-level functions and classes exposed by the <code>metalq</code> package.</p>"},{"location":"api/#execution","title":"Execution","text":"<p>Execute a circuit and return results (counts or statevector).</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>The quantum circuit to run.</p> required <code>shots</code> <code>int</code> <p>Number of measurement shots. If 0, returns statevector (if supported).</p> <code>1024</code> <code>backend</code> <code>str</code> <p>Backend name ('mps' or 'cpu').</p> <code>'mps'</code> <code>params</code> <code>Optional[Union[Dict, List[float]]]</code> <p>Parameters to bind to the circuit.</p> <code>None</code> <p>Returns:</p> Type Description <code>Result</code> <p>Result object containing 'counts' or 'statevector'.</p> Source code in <code>metalq/api.py</code> <pre><code>def run(circuit: Circuit, \n        shots: int = 1024, \n        backend: str = 'mps', \n        params: Optional[Union[Dict, List[float]]] = None) -&gt; Result:\n    \"\"\"\n    Execute a circuit and return results (counts or statevector).\n\n    Args:\n        circuit: The quantum circuit to run.\n        shots: Number of measurement shots. If 0, returns statevector (if supported).\n        backend: Backend name ('mps' or 'cpu').\n        params: Parameters to bind to the circuit.\n\n    Returns:\n        Result object containing 'counts' or 'statevector'.\n    \"\"\"\n    bk = get_backend(backend)\n    res_dict = bk.run(circuit, shots=shots, params=params)\n\n    return Result(\n        counts=res_dict.get('counts'),\n        statevector=res_dict.get('statevector'),\n        metadata={'backend': backend, 'time_ms': res_dict.get('time_ms')}\n    )\n</code></pre> <p>Calculate the expectation value . <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>The ansatz circuit.</p> required <code>hamiltonian</code> <code>Hamiltonian</code> <p>The observable.</p> required <code>backend</code> <code>str</code> <p>Backend name ('mps' or 'cpu').</p> <code>'mps'</code> <code>params</code> <code>Optional[Union[Dict, List[float]]]</code> <p>Parameters to bind.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Expectation value (float).</p> Source code in <code>metalq/api.py</code> <pre><code>def expect(circuit: Circuit, \n           hamiltonian: Hamiltonian, \n           backend: str = 'mps', \n           params: Optional[Union[Dict, List[float]]] = None) -&gt; float:\n    \"\"\"\n    Calculate the expectation value &lt;psi|H|psi&gt;.\n\n    Args:\n        circuit: The ansatz circuit.\n        hamiltonian: The observable.\n        backend: Backend name ('mps' or 'cpu').\n        params: Parameters to bind.\n\n    Returns:\n        Expectation value (float).\n    \"\"\"\n    bk = get_backend(backend)\n    return bk.expectation(circuit, hamiltonian, params=params)\n</code></pre> <p>Get the statevector of a circuit.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>The quantum circuit.</p> required <code>backend</code> <code>str</code> <p>Backend name.</p> <code>'mps'</code> <code>params</code> <code>Optional[Union[Dict, List[float]]]</code> <p>Parameters to bind.</p> <code>None</code> <p>Returns:</p> Type Description <p>numpy.ndarray: Statevector.</p> Source code in <code>metalq/api.py</code> <pre><code>def statevector(circuit: Circuit, \n                backend: str = 'mps', \n                params: Optional[Union[Dict, List[float]]] = None):\n    \"\"\"\n    Get the statevector of a circuit.\n\n    Args:\n        circuit: The quantum circuit.\n        backend: Backend name.\n        params: Parameters to bind.\n\n    Returns:\n        numpy.ndarray: Statevector.\n    \"\"\"\n    bk = get_backend(backend)\n    return bk.statevector(circuit, params=params)\n</code></pre>"},{"location":"api/#results","title":"Results","text":"<p>Result of quantum circuit execution.</p> <p>Attributes:</p> Name Type Description <code>counts</code> <code>Dict[str, int]</code> <p>Measurement counts (bitstring -&gt; count)</p> <code>statevector</code> <code>Optional[ndarray]</code> <p>Full statevector (if shots=0)</p> <code>expectation</code> <code>Optional[float]</code> <p>Expectation value (if observable specified)</p> Source code in <code>metalq/result.py</code> <pre><code>class Result:\n    \"\"\"\n    Result of quantum circuit execution.\n\n    Attributes:\n        counts: Measurement counts (bitstring -&gt; count)\n        statevector: Full statevector (if shots=0)\n        expectation: Expectation value (if observable specified)\n    \"\"\"\n\n    __slots__ = ('_counts', '_statevector', '_expectation', '_metadata')\n\n    def __init__(self,\n                 counts: Optional[Dict[str, int]] = None,\n                 statevector: Optional[np.ndarray] = None,\n                 expectation: Optional[float] = None,\n                 metadata: Optional[Dict] = None):\n        \"\"\"\n        Initialize result.\n\n        Args:\n            counts: Measurement counts\n            statevector: State vector (complex array)\n            expectation: Expectation value\n            metadata: Additional metadata (timing, backend info, etc.)\n        \"\"\"\n        self._counts = counts or {}\n        self._statevector = statevector\n        self._expectation = expectation\n        self._metadata = metadata or {}\n\n    # ========================================================================\n    # Properties\n    # ========================================================================\n\n    @property\n    def counts(self) -&gt; Dict[str, int]:\n        \"\"\"Get measurement counts (copy).\"\"\"\n        return self._counts.copy()\n\n    @property\n    def statevector(self) -&gt; Optional[np.ndarray]:\n        \"\"\"Get statevector (if available).\"\"\"\n        if self._statevector is None:\n            return None\n        return self._statevector.copy()\n\n    @property\n    def expectation(self) -&gt; Optional[float]:\n        \"\"\"Get expectation value (if computed).\"\"\"\n        return self._expectation\n\n    @property\n    def metadata(self) -&gt; Dict:\n        \"\"\"Get execution metadata.\"\"\"\n        return self._metadata.copy()\n\n    @property\n    def total_counts(self) -&gt; int:\n        \"\"\"Get total number of shots.\"\"\"\n        return sum(self._counts.values())\n\n    @property\n    def probabilities(self) -&gt; Dict[str, float]:\n        \"\"\"\n        Get probability distribution from counts.\n\n        Returns:\n            Dict mapping bitstrings to probabilities\n        \"\"\"\n        total = self.total_counts\n        if total == 0:\n            return {}\n        return {k: v / total for k, v in self._counts.items()}\n\n    # ========================================================================\n    # Analysis Methods\n    # ========================================================================\n\n    def most_frequent(self) -&gt; str:\n        \"\"\"\n        Get the most frequently measured bitstring.\n\n        Returns:\n            Most common measurement result\n\n        Raises:\n            ValueError: If no measurements available\n        \"\"\"\n        if not self._counts:\n            raise ValueError(\"No measurement results available\")\n        return max(self._counts, key=self._counts.get)\n\n    def get_counts(self, num_bits: Optional[int] = None) -&gt; Dict[str, int]:\n        \"\"\"\n        Get counts with optional bit padding.\n\n        Args:\n            num_bits: Pad bitstrings to this length\n\n        Returns:\n            Measurement counts\n        \"\"\"\n        if num_bits is None:\n            return self.counts\n\n        return {\n            k.zfill(num_bits): v \n            for k, v in self._counts.items()\n        }\n\n    def probability(self, bitstring: str) -&gt; float:\n        \"\"\"\n        Get probability of a specific outcome.\n\n        Args:\n            bitstring: Measurement outcome\n\n        Returns:\n            Probability (0 if not observed)\n        \"\"\"\n        total = self.total_counts\n        if total == 0:\n            return 0.0\n        return self._counts.get(bitstring, 0) / total\n\n    def expectation_from_counts(self, observable_fn) -&gt; float:\n        \"\"\"\n        Compute expectation value from counts using a function.\n\n        Args:\n            observable_fn: Function mapping bitstring to observable value\n\n        Returns:\n            Expectation value\n\n        Example:\n            # Compute &lt;Z\u2080&gt; from counts\n            exp_z0 = result.expectation_from_counts(\n                lambda s: 1 if s[-1] == '0' else -1\n            )\n        \"\"\"\n        total = self.total_counts\n        if total == 0:\n            return 0.0\n\n        return sum(\n            count * observable_fn(bitstring)\n            for bitstring, count in self._counts.items()\n        ) / total\n\n    def marginal(self, qubits: List[int]) -&gt; Dict[str, int]:\n        \"\"\"\n        Get marginal distribution over specified qubits.\n\n        Args:\n            qubits: List of qubit indices to keep\n\n        Returns:\n            Marginal counts\n\n        Example:\n            # Get counts for qubits 0 and 2 only\n            marginal = result.marginal([0, 2])\n        \"\"\"\n        if not self._counts:\n            return {}\n\n        # Determine total number of qubits from bitstring length\n        sample_key = next(iter(self._counts))\n        n_qubits = len(sample_key)\n\n        marginal_counts = {}\n        for bitstring, count in self._counts.items():\n            # Extract specified qubits (bitstring is big-endian: q_{n-1}...q_1 q_0)\n            marginal_bits = ''.join(bitstring[n_qubits - 1 - q] for q in sorted(qubits, reverse=True))\n            marginal_counts[marginal_bits] = marginal_counts.get(marginal_bits, 0) + count\n\n        return marginal_counts\n\n    # ========================================================================\n    # Statevector Methods\n    # ========================================================================\n\n    def amplitudes(self) -&gt; Optional[Dict[str, complex]]:\n        \"\"\"\n        Get amplitudes as dict (bitstring -&gt; complex amplitude).\n\n        Returns:\n            Dict mapping bitstrings to amplitudes, or None if no statevector\n        \"\"\"\n        if self._statevector is None:\n            return None\n\n        n_qubits = int(np.log2(len(self._statevector)))\n        return {\n            format(i, f'0{n_qubits}b'): self._statevector[i]\n            for i in range(len(self._statevector))\n        }\n\n    def probabilities_from_statevector(self) -&gt; Optional[Dict[str, float]]:\n        \"\"\"\n        Get probabilities from statevector.\n\n        Returns:\n            Dict mapping bitstrings to probabilities\n        \"\"\"\n        if self._statevector is None:\n            return None\n\n        n_qubits = int(np.log2(len(self._statevector)))\n        probs = np.abs(self._statevector) ** 2\n\n        return {\n            format(i, f'0{n_qubits}b'): probs[i]\n            for i in range(len(probs))\n            if probs[i] &gt; 1e-10  # Filter near-zero probabilities\n        }\n\n    # ========================================================================\n    # String Representation\n    # ========================================================================\n\n    def __repr__(self) -&gt; str:\n        parts = []\n        if self._counts:\n            parts.append(f\"counts={self._counts}\")\n        if self._statevector is not None:\n            parts.append(f\"statevector[{len(self._statevector)}]\")\n        if self._expectation is not None:\n            parts.append(f\"expectation={self._expectation:.6f}\")\n\n        return f\"Result({', '.join(parts)})\"\n\n    def __str__(self) -&gt; str:\n        if self._counts:\n            return str(self._counts)\n        elif self._statevector is not None:\n            return f\"Statevector({len(self._statevector)} amplitudes)\"\n        elif self._expectation is not None:\n            return f\"Expectation: {self._expectation:.6f}\"\n        else:\n            return \"Result(empty)\"\n</code></pre>"},{"location":"api/#metalq.Result.counts","title":"<code>counts</code>  <code>property</code>","text":"<p>Get measurement counts (copy).</p>"},{"location":"api/#metalq.Result.expectation","title":"<code>expectation</code>  <code>property</code>","text":"<p>Get expectation value (if computed).</p>"},{"location":"api/#metalq.Result.metadata","title":"<code>metadata</code>  <code>property</code>","text":"<p>Get execution metadata.</p>"},{"location":"api/#metalq.Result.probabilities","title":"<code>probabilities</code>  <code>property</code>","text":"<p>Get probability distribution from counts.</p> <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dict mapping bitstrings to probabilities</p>"},{"location":"api/#metalq.Result.statevector","title":"<code>statevector</code>  <code>property</code>","text":"<p>Get statevector (if available).</p>"},{"location":"api/#metalq.Result.total_counts","title":"<code>total_counts</code>  <code>property</code>","text":"<p>Get total number of shots.</p>"},{"location":"api/#metalq.Result.__init__","title":"<code>__init__(counts=None, statevector=None, expectation=None, metadata=None)</code>","text":"<p>Initialize result.</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>Optional[Dict[str, int]]</code> <p>Measurement counts</p> <code>None</code> <code>statevector</code> <code>Optional[ndarray]</code> <p>State vector (complex array)</p> <code>None</code> <code>expectation</code> <code>Optional[float]</code> <p>Expectation value</p> <code>None</code> <code>metadata</code> <code>Optional[Dict]</code> <p>Additional metadata (timing, backend info, etc.)</p> <code>None</code> Source code in <code>metalq/result.py</code> <pre><code>def __init__(self,\n             counts: Optional[Dict[str, int]] = None,\n             statevector: Optional[np.ndarray] = None,\n             expectation: Optional[float] = None,\n             metadata: Optional[Dict] = None):\n    \"\"\"\n    Initialize result.\n\n    Args:\n        counts: Measurement counts\n        statevector: State vector (complex array)\n        expectation: Expectation value\n        metadata: Additional metadata (timing, backend info, etc.)\n    \"\"\"\n    self._counts = counts or {}\n    self._statevector = statevector\n    self._expectation = expectation\n    self._metadata = metadata or {}\n</code></pre>"},{"location":"api/#metalq.Result.amplitudes","title":"<code>amplitudes()</code>","text":"<p>Get amplitudes as dict (bitstring -&gt; complex amplitude).</p> <p>Returns:</p> Type Description <code>Optional[Dict[str, complex]]</code> <p>Dict mapping bitstrings to amplitudes, or None if no statevector</p> Source code in <code>metalq/result.py</code> <pre><code>def amplitudes(self) -&gt; Optional[Dict[str, complex]]:\n    \"\"\"\n    Get amplitudes as dict (bitstring -&gt; complex amplitude).\n\n    Returns:\n        Dict mapping bitstrings to amplitudes, or None if no statevector\n    \"\"\"\n    if self._statevector is None:\n        return None\n\n    n_qubits = int(np.log2(len(self._statevector)))\n    return {\n        format(i, f'0{n_qubits}b'): self._statevector[i]\n        for i in range(len(self._statevector))\n    }\n</code></pre>"},{"location":"api/#metalq.Result.expectation_from_counts","title":"<code>expectation_from_counts(observable_fn)</code>","text":"<p>Compute expectation value from counts using a function.</p> <p>Parameters:</p> Name Type Description Default <code>observable_fn</code> <p>Function mapping bitstring to observable value</p> required <p>Returns:</p> Type Description <code>float</code> <p>Expectation value</p> Example"},{"location":"api/#metalq.Result.expectation_from_counts--compute-from-counts","title":"Compute  from counts <p>exp_z0 = result.expectation_from_counts(     lambda s: 1 if s[-1] == '0' else -1 )</p>   Source code in <code>metalq/result.py</code> <pre><code>def expectation_from_counts(self, observable_fn) -&gt; float:\n    \"\"\"\n    Compute expectation value from counts using a function.\n\n    Args:\n        observable_fn: Function mapping bitstring to observable value\n\n    Returns:\n        Expectation value\n\n    Example:\n        # Compute &lt;Z\u2080&gt; from counts\n        exp_z0 = result.expectation_from_counts(\n            lambda s: 1 if s[-1] == '0' else -1\n        )\n    \"\"\"\n    total = self.total_counts\n    if total == 0:\n        return 0.0\n\n    return sum(\n        count * observable_fn(bitstring)\n        for bitstring, count in self._counts.items()\n    ) / total\n</code></pre>","text":""},{"location":"api/#metalq.Result.get_counts","title":"<code>get_counts(num_bits=None)</code>","text":"<p>Get counts with optional bit padding.</p> <p>Parameters:</p> Name Type Description Default <code>num_bits</code> <code>Optional[int]</code> <p>Pad bitstrings to this length</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Measurement counts</p> Source code in <code>metalq/result.py</code> <pre><code>def get_counts(self, num_bits: Optional[int] = None) -&gt; Dict[str, int]:\n    \"\"\"\n    Get counts with optional bit padding.\n\n    Args:\n        num_bits: Pad bitstrings to this length\n\n    Returns:\n        Measurement counts\n    \"\"\"\n    if num_bits is None:\n        return self.counts\n\n    return {\n        k.zfill(num_bits): v \n        for k, v in self._counts.items()\n    }\n</code></pre>"},{"location":"api/#metalq.Result.marginal","title":"<code>marginal(qubits)</code>","text":"<p>Get marginal distribution over specified qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>List[int]</code> <p>List of qubit indices to keep</p> required <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Marginal counts</p> Example Source code in <code>metalq/result.py</code> <pre><code>def marginal(self, qubits: List[int]) -&gt; Dict[str, int]:\n    \"\"\"\n    Get marginal distribution over specified qubits.\n\n    Args:\n        qubits: List of qubit indices to keep\n\n    Returns:\n        Marginal counts\n\n    Example:\n        # Get counts for qubits 0 and 2 only\n        marginal = result.marginal([0, 2])\n    \"\"\"\n    if not self._counts:\n        return {}\n\n    # Determine total number of qubits from bitstring length\n    sample_key = next(iter(self._counts))\n    n_qubits = len(sample_key)\n\n    marginal_counts = {}\n    for bitstring, count in self._counts.items():\n        # Extract specified qubits (bitstring is big-endian: q_{n-1}...q_1 q_0)\n        marginal_bits = ''.join(bitstring[n_qubits - 1 - q] for q in sorted(qubits, reverse=True))\n        marginal_counts[marginal_bits] = marginal_counts.get(marginal_bits, 0) + count\n\n    return marginal_counts\n</code></pre>"},{"location":"api/#metalq.Result.marginal--get-counts-for-qubits-0-and-2-only","title":"Get counts for qubits 0 and 2 only <p>marginal = result.marginal([0, 2])</p>","text":""},{"location":"api/#metalq.Result.most_frequent","title":"<code>most_frequent()</code>","text":"<p>Get the most frequently measured bitstring.</p> <p>Returns:</p> Type Description <code>str</code> <p>Most common measurement result</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no measurements available</p> Source code in <code>metalq/result.py</code> <pre><code>def most_frequent(self) -&gt; str:\n    \"\"\"\n    Get the most frequently measured bitstring.\n\n    Returns:\n        Most common measurement result\n\n    Raises:\n        ValueError: If no measurements available\n    \"\"\"\n    if not self._counts:\n        raise ValueError(\"No measurement results available\")\n    return max(self._counts, key=self._counts.get)\n</code></pre>"},{"location":"api/#metalq.Result.probabilities_from_statevector","title":"<code>probabilities_from_statevector()</code>","text":"<p>Get probabilities from statevector.</p> <p>Returns:</p> Type Description <code>Optional[Dict[str, float]]</code> <p>Dict mapping bitstrings to probabilities</p> Source code in <code>metalq/result.py</code> <pre><code>def probabilities_from_statevector(self) -&gt; Optional[Dict[str, float]]:\n    \"\"\"\n    Get probabilities from statevector.\n\n    Returns:\n        Dict mapping bitstrings to probabilities\n    \"\"\"\n    if self._statevector is None:\n        return None\n\n    n_qubits = int(np.log2(len(self._statevector)))\n    probs = np.abs(self._statevector) ** 2\n\n    return {\n        format(i, f'0{n_qubits}b'): probs[i]\n        for i in range(len(probs))\n        if probs[i] &gt; 1e-10  # Filter near-zero probabilities\n    }\n</code></pre>"},{"location":"api/#metalq.Result.probability","title":"<code>probability(bitstring)</code>","text":"<p>Get probability of a specific outcome.</p> <p>Parameters:</p> Name Type Description Default <code>bitstring</code> <code>str</code> <p>Measurement outcome</p> required <p>Returns:</p> Type Description <code>float</code> <p>Probability (0 if not observed)</p> Source code in <code>metalq/result.py</code> <pre><code>def probability(self, bitstring: str) -&gt; float:\n    \"\"\"\n    Get probability of a specific outcome.\n\n    Args:\n        bitstring: Measurement outcome\n\n    Returns:\n        Probability (0 if not observed)\n    \"\"\"\n    total = self.total_counts\n    if total == 0:\n        return 0.0\n    return self._counts.get(bitstring, 0) / total\n</code></pre>"},{"location":"api/algorithms/","title":"Algorithms","text":"<p>Built-in variational algorithms.</p>"},{"location":"api/algorithms/#vqe","title":"VQE","text":"<p>Variational Quantum Eigensolver implementation using Metal-Q Adjoint Differentiation.</p> <p>Parameters:</p> Name Type Description Default <code>ansatz</code> <code>Circuit</code> <p>Parameterized quantum circuit.</p> required <code>optimizer_cls</code> <code>Optimizer</code> <p>Optimizer class (default: Adam).</p> <code>Adam</code> <code>optimizer_kwargs</code> <code>dict</code> <p>Arguments for optimizer (default: lr=0.1).</p> <code>None</code> <code>backend</code> <code>str</code> <p>Backend name ('mps' or 'cpu').</p> <code>'mps'</code> Source code in <code>metalq/algorithms/vqe.py</code> <pre><code>class VQE:\n    \"\"\"\n    Variational Quantum Eigensolver implementation using Metal-Q Adjoint Differentiation.\n\n    Args:\n        ansatz (Circuit): Parameterized quantum circuit.\n        optimizer_cls (torch.optim.Optimizer): Optimizer class (default: Adam).\n        optimizer_kwargs (dict): Arguments for optimizer (default: lr=0.1).\n        backend (str): Backend name ('mps' or 'cpu').\n    \"\"\"\n    def __init__(self, \n                 ansatz: Circuit, \n                 optimizer_cls=optim.Adam, \n                 optimizer_kwargs: Optional[Dict] = None,\n                 backend: str = 'mps'):\n        self.ansatz = ansatz\n        self.optimizer_cls = optimizer_cls\n        self.optimizer_kwargs = optimizer_kwargs if optimizer_kwargs is not None else {'lr': 0.1}\n        self.backend_name = backend\n\n    def compute_minimum_eigenvalue(self, hamiltonian: Hamiltonian, max_iter: int = 100, tol: float = 1e-4) -&gt; VQEResult:\n        \"\"\"\n        Run the VQE optimization loop.\n\n        Args:\n            hamiltonian: The Hamiltonian to minimize.\n            max_iter: Maximum optimization steps.\n            tol: Convergence tolerance.\n\n        Returns:\n            VQEResult object.\n        \"\"\"\n        # 1. Setup Quantum Layer\n        layer = QuantumLayer(self.ansatz, hamiltonian, backend_name=self.backend_name)\n\n        # 2. Setup Optimizer\n        optimizer = self.optimizer_cls(layer.parameters(), **self.optimizer_kwargs)\n\n        # 3. Optimization Loop\n        history = []\n        best_loss = float('inf')\n        patience = 5\n        no_improv = 0\n\n        for i in range(max_iter):\n            optimizer.zero_grad()\n            loss = layer()\n            loss.backward()\n            optimizer.step()\n\n            val = loss.item()\n            history.append(val)\n\n            # Simple early stopping\n            if abs(val - best_loss) &lt; tol:\n                no_improv += 1\n            else:\n                no_improv = 0\n\n            if val &lt; best_loss:\n                best_loss = val\n\n            if no_improv &gt;= patience:\n                break\n\n        # 4. Extract results\n        opt_params = layer.weights.detach().numpy().tolist()\n\n        return VQEResult(best_loss, opt_params, history)\n</code></pre>"},{"location":"api/algorithms/#metalq.algorithms.VQE.compute_minimum_eigenvalue","title":"<code>compute_minimum_eigenvalue(hamiltonian, max_iter=100, tol=0.0001)</code>","text":"<p>Run the VQE optimization loop.</p> <p>Parameters:</p> Name Type Description Default <code>hamiltonian</code> <code>Hamiltonian</code> <p>The Hamiltonian to minimize.</p> required <code>max_iter</code> <code>int</code> <p>Maximum optimization steps.</p> <code>100</code> <code>tol</code> <code>float</code> <p>Convergence tolerance.</p> <code>0.0001</code> <p>Returns:</p> Type Description <code>VQEResult</code> <p>VQEResult object.</p> Source code in <code>metalq/algorithms/vqe.py</code> <pre><code>def compute_minimum_eigenvalue(self, hamiltonian: Hamiltonian, max_iter: int = 100, tol: float = 1e-4) -&gt; VQEResult:\n    \"\"\"\n    Run the VQE optimization loop.\n\n    Args:\n        hamiltonian: The Hamiltonian to minimize.\n        max_iter: Maximum optimization steps.\n        tol: Convergence tolerance.\n\n    Returns:\n        VQEResult object.\n    \"\"\"\n    # 1. Setup Quantum Layer\n    layer = QuantumLayer(self.ansatz, hamiltonian, backend_name=self.backend_name)\n\n    # 2. Setup Optimizer\n    optimizer = self.optimizer_cls(layer.parameters(), **self.optimizer_kwargs)\n\n    # 3. Optimization Loop\n    history = []\n    best_loss = float('inf')\n    patience = 5\n    no_improv = 0\n\n    for i in range(max_iter):\n        optimizer.zero_grad()\n        loss = layer()\n        loss.backward()\n        optimizer.step()\n\n        val = loss.item()\n        history.append(val)\n\n        # Simple early stopping\n        if abs(val - best_loss) &lt; tol:\n            no_improv += 1\n        else:\n            no_improv = 0\n\n        if val &lt; best_loss:\n            best_loss = val\n\n        if no_improv &gt;= patience:\n            break\n\n    # 4. Extract results\n    opt_params = layer.weights.detach().numpy().tolist()\n\n    return VQEResult(best_loss, opt_params, history)\n</code></pre>"},{"location":"api/algorithms/#qaoa","title":"QAOA","text":"<p>               Bases: <code>VQE</code></p> <p>Quantum Approximate Optimization Algorithm. Constructs the ansatz for a given problem Hamiltonian and runs VQE.</p> Source code in <code>metalq/algorithms/qaoa.py</code> <pre><code>class QAOA(VQE):\n    \"\"\"\n    Quantum Approximate Optimization Algorithm.\n    Constructs the ansatz for a given problem Hamiltonian and runs VQE.\n    \"\"\"\n    def __init__(self, \n                 hamiltonian: Hamiltonian, \n                 reps: int = 1, \n                 backend: str = 'mps'):\n\n        if hasattr(hamiltonian, 'terms'):\n            self.problem_hamiltonian = hamiltonian\n        else:\n            # Assume PauliTerm or list-like\n            from ..spin import Hamiltonian\n            self.problem_hamiltonian = Hamiltonian([hamiltonian]) if not isinstance(hamiltonian, Hamiltonian) else hamiltonian\n\n        self.reps = reps\n\n        # Build Ansatz\n        ansatz = self._build_ansatz(self.problem_hamiltonian, reps)\n\n        # Initialize VQE parent\n        super().__init__(ansatz, backend=backend)\n\n    def _build_ansatz(self, cost_h: Hamiltonian, p: int) -&gt; Circuit:\n        \"\"\"\n        Construct standard QAOA ansatz: |+&gt;^n -&gt; [U_C(gamma) -&gt; U_B(beta)]^p\n        \"\"\"\n        n_qubits = cost_h.num_qubits\n        qc = Circuit(n_qubits)\n\n        # 1. Initialize |+&gt;\n        for i in range(n_qubits):\n            qc.h(i)\n\n        # 2. Layers\n        for layer in range(p):\n            gamma = Parameter(f'gamma_{layer}')\n            beta = Parameter(f'beta_{layer}')\n\n            # Cost Hamiltonian Evolution U_C = exp(-i gamma H_C)\n            # H_C is typically sum of ZZ terms (Ising).\n            # We assume cost_h is composed of Pauli Terms.\n            # Evolution exp(-i gamma Z_i Z_j) is: CNOT(i,j) RZ(2*gamma, j) CNOT(i,j)\n\n            for term in cost_h.terms:\n                # Assuming term is Z type (Diagonal) for standard MAXCUT\n                # Metal-Q native backend might eventually support exponential of Hamiltonian directly.\n                # For now decompose:\n                param_factor = term.coeff.real * gamma # * 2 for gate definition? \n                # RZ(theta) = exp(-i theta/2 Z). We want exp(-i (gamma*coeff) Z).\n                # So theta/2 = gamma*coeff =&gt; theta = 2 * gamma * coeff.\n\n                ops = term.ops # [(P, q), ...]\n\n                if len(ops) == 0: continue # Identity\n\n                # CNOT ladder for Multi-Z\n                # Simple case: ZZ on q1, q2\n                # CN(q1, q2), RZ(2*gamma*coeff, q2), CN(q1, q2)\n\n                # Collect qubit indices\n                indices = [q for _, q in ops]\n\n                # Apply CNOTs down to last qubit\n                for k in range(len(indices)-1):\n                    qc.cx(indices[k], indices[k+1])\n\n                # RZ on last qubit\n                last_q = indices[-1]\n                # Note: We bind the parameter expression (2 * coeff * gamma)\n                # Currently ParameterExpression logic in Phase 1 might be simple.\n                # For MVP: Just pass gamma, and we trust user or handle coeff later.\n                # BUT wait, coeff is fixed number.\n                # qc.rz(gamma, last_q) # Using implicit coeff? No.\n                # We need Expression support. If not present, we can't fully do generic QAOA easily without re-building circuit.\n                # Alternatively, we just create parameter for each term? Bad scaling.\n\n                # Let's assume simplest MaxCut for MVP: Coeff=1 or handle manually if expression support weak.\n                # `qc.rz(2.0 * gamma, last_q)` if Parameter supports mul.\n                # Checking parameter.py... Phase 1 implemented ParameterExpression.\n\n                qc.rz(2.0 * term.coeff.real * gamma, last_q)\n\n                # Inverse CNOTs\n                for k in range(len(indices)-2, -1, -1):\n                    qc.cx(indices[k], indices[k+1])\n\n            # Mixer Hamiltonian Evolution U_B = exp(-i beta sum X_i)\n            # = Product RX(2*beta, i)\n            for i in range(n_qubits):\n                qc.rx(2.0 * beta, i)\n\n        return qc\n\n    def compute(self, max_iter: int = 100) -&gt; VQEResult:\n        return self.compute_minimum_eigenvalue(self.problem_hamiltonian, max_iter)\n</code></pre>"},{"location":"api/backends/","title":"Backends","text":""},{"location":"api/backends/#mpsbackend-gpu","title":"MPSBackend (GPU)","text":"<p>               Bases: <code>Backend</code></p> <p>GPU-accelerated backend using Apple Metal Performance Shaders.</p> Source code in <code>metalq/backends/mps/backend.py</code> <pre><code>class MPSBackend(Backend):\n    \"\"\"\n    GPU-accelerated backend using Apple Metal Performance Shaders.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize MPS backend.\"\"\"\n        self._lib = self._load_library()\n        self._lib = self._load_library()\n\n        # Check if building documentation or running on non-macOS\n        if not self._lib:\n            if os.environ.get('METALQ_DOCS_BUILD') == '1' or os.environ.get('READTHEDOCS') == 'True':\n                # Create a mock library for documentation build\n                class MockLib:\n                    def __getattr__(self, name):\n                        return ctypes.CFUNCTYPE(None) \n                    def metalq_create_context(self): return ctypes.c_void_p(1)\n                    def metalq_is_supported(self): return True\n                    def metalq_destroy_context(self, ctx): pass\n                    def metalq_run(self, *args): return 0\n                    def metalq_gradient_adjoint(self, *args): return 0\n\n                self._lib = MockLib()\n            else:\n                raise RuntimeError(\"Failed to load native MetalQ library\")\n\n        # Define function signatures\n        self._lib.metalq_create_context.restype = ctypes.c_void_p\n        self._lib.metalq_is_supported.restype = ctypes.c_bool\n\n        self._lib.metalq_destroy_context.argtypes = [ctypes.c_void_p]\n        self._lib.metalq_run.argtypes = [\n            ctypes.c_void_p,\n            ctypes.c_uint32,\n            ctypes.POINTER(MQGate),\n            ctypes.c_uint32,\n            ctypes.c_uint32,\n            ctypes.POINTER(MQComplex),\n            ctypes.POINTER(ctypes.c_uint64)\n        ]\n\n        self._lib.metalq_gradient_adjoint.argtypes = [\n            ctypes.c_void_p,\n            ctypes.c_uint32,\n            ctypes.POINTER(MQGate),\n            ctypes.c_uint32,\n            ctypes.c_void_p, # MQHamiltonian*\n            ctypes.POINTER(ctypes.c_double)\n        ]\n\n        # Initialize native context\n        self._ctx = self._lib.metalq_create_context()\n        if not self._ctx:\n            raise RuntimeError(\"Failed to create MetalQ context\")\n\n    def __del__(self):\n        \"\"\"Cleanup native resources.\"\"\"\n        if hasattr(self, '_lib') and self._lib and hasattr(self, '_ctx') and self._ctx:\n            self._lib.metalq_destroy_context(self._ctx)\n\n    def _load_library(self):\n        \"\"\"Load the native shared library.\"\"\"\n        lib_name = \"libmetalq.dylib\"\n        # Search paths\n        paths = [\n            os.path.abspath(f\"native/build/{lib_name}\"),\n            os.path.join(os.path.dirname(__file__), \"../../../native/build\", lib_name),\n            os.path.join(os.path.dirname(__file__), \"../../../../native/build\", lib_name), # In case of deeper nesting\n            f\"/usr/local/lib/{lib_name}\"\n        ]\n\n        for path in paths:\n            if os.path.exists(path):\n                try:\n                    return ctypes.CDLL(path)\n                except OSError:\n                    continue\n\n        # Fallback for installed package (if bundled)\n        # ...\n\n        return None\n\n    def is_available(self) -&gt; bool:\n        \"\"\"Check if Metal is supported on this device.\"\"\"\n        if not self._lib: return False\n        return bool(self._lib.metalq_is_supported())\n\n    @property\n    def name(self) -&gt; str:\n        return 'mps'\n\n    @property\n    def max_qubits(self) -&gt; int:\n        return 30\n\n    def run(self, \n            circuit: 'Circuit', \n            shots: int = 0,\n            params: Optional[Union[Dict, List[float]]] = None) -&gt; Dict:\n        \"\"\"Execute circuit on GPU.\"\"\"\n\n        # Bind parameters\n        if params is not None:\n            circuit = circuit.bind_parameters(params)\n\n        num_qubits = circuit.num_qubits\n\n        # Convert gates to C structure\n        c_gates = (MQGate * len(circuit.gates))()\n\n        for i, gate in enumerate(circuit.gates):\n            gt = c_gates[i]\n\n            # Map name to ID\n            gname = gate.name.lower()\n\n            if gname in GATE_MAP:\n                gt.type = GATE_MAP[gname]\n                # Copy params directly\n                gt.num_params = len(gate.params)\n                for j, p in enumerate(gate.params):\n                    if j &lt; 3: gt.params[j] = float(p)\n\n            # Decompositions / Mappings\n            elif gname == 'sdg':\n                gt.type = GATE_MAP['p']\n                gt.num_params = 1\n                gt.params[0] = -np.pi/2\n            elif gname == 'tdg':\n                gt.type = GATE_MAP['p']\n                gt.num_params = 1\n                gt.params[0] = -np.pi/4\n            elif gname == 'sx':\n                gt.type = GATE_MAP['rx']\n                gt.num_params = 1\n                gt.params[0] = np.pi/2\n            elif gname == 'sxdg':\n                gt.type = GATE_MAP['rx']\n                gt.num_params = 1\n                gt.params[0] = -np.pi/2\n\n            else:\n                # Fallback or error? For MVP, skip or error.\n                print(f\"Warning: Unsupported gate {gname} for MPS, skipping/mapping to identity.\")\n                gt.type = 999 \n\n            # Qubits\n            gt.num_qubits = len(gate.qubits)\n            for j, q in enumerate(gate.qubits):\n                if j &lt; 3: gt.qubits[j] = q\n\n\n        # Allocate output buffers\n        # Statevector: 2^n * 8 bytes (float complex)\n        sv_size = 1 &lt;&lt; num_qubits\n        statevector = np.zeros(sv_size, dtype=np.complex64)\n\n        # We need to pass pointer to numpy data\n        sv_ptr = statevector.ctypes.data_as(ctypes.POINTER(MQComplex))\n\n        # Measurement counts (if shots &gt; 0)\n        # Native API signature:\n        # int metalq_run(ctx, nq, gates, ng, shots, sv_out, counts_out)\n\n        # Counts logic in native is not fully implemented in verify/plan, \n        # but let's assume we get statevector back and sample in Python for MVP if shots&gt;0\n        # for maximum reliability in Phase 2/3 transition.\n        # Or pass explicit None.\n\n        # print(f\"DEBUG: Calling metalq_run with {num_qubits} qubits, {len(circuit.gates)} gates\")\n        res_code = self._lib.metalq_run(\n            self._ctx,\n            ctypes.c_uint32(num_qubits),\n            c_gates,\n            ctypes.c_uint32(len(circuit.gates)),\n            ctypes.c_uint32(0), # shots=0 for now in native to just get SV\n            sv_ptr,\n            None # counts out\n        )\n        # print(f\"DEBUG: metalq_run returned {res_code}\")\n\n        if res_code != 0:\n            raise RuntimeError(f\"Metal execution failed with code {res_code}\")\n\n        result = {}\n        result['statevector'] = statevector\n\n        # If shots requested, sample from statevector on CPU for now (hybrid)\n        # Implementing full GPU sampling is an optimization.\n        if shots &gt; 0:\n            from ..cpu.measurement import sample_counts\n            result['counts'] = sample_counts(statevector, shots, num_qubits)\n\n        return result\n\n    def statevector(self, circuit: 'Circuit', params=None) -&gt; np.ndarray:\n        res = self.run(circuit, shots=0, params=params)\n        return res['statevector']\n\n    def expectation(self, circuit: 'Circuit', hamiltonian: 'Hamiltonian', params=None) -&gt; float:\n        sv = self.statevector(circuit, params)\n        # Calculate &lt;psi|H|psi&gt; on CPU\n        # H |psi&gt;\n        h_psi = hamiltonian.to_matrix(circuit.num_qubits) @ sv\n        return np.real(np.vdot(sv, h_psi))\n\n    def gradient(self, circuit: 'Circuit', hamiltonian: 'Hamiltonian', params: List[float], method='parameter_shift') -&gt; np.ndarray:\n        if method != 'adjoint':\n             from ..cpu.gradient import parameter_shift_gradient\n             return parameter_shift_gradient(self, circuit, hamiltonian, params)\n\n        # Native Adjoint Differentiation\n        if params is not None:\n            circuit = circuit.bind_parameters(params)\n\n        # 1. Marshal Gates (Same as run)\n        c_gates = (MQGate * len(circuit.gates))()\n        for i, gate in enumerate(circuit.gates):\n            gt = c_gates[i]\n            gname = gate.name.lower()\n            if gname in GATE_MAP:\n                gt.type = GATE_MAP[gname]\n            else:\n                gt.type = 999 \n            gt.num_qubits = len(gate.qubits)\n            for j, q in enumerate(gate.qubits): \n                if j &lt; 3: gt.qubits[j] = q\n            gt.num_params = len(gate.params)\n            for j, p in enumerate(gate.params):\n                if j &lt; 3: gt.params[j] = float(p)\n\n        # 2. Marshal Hamiltonian\n        from ...spin import PauliTerm, Hamiltonian\n        if isinstance(hamiltonian, PauliTerm):\n             hamiltonian = Hamiltonian([hamiltonian])\n\n        terms = hamiltonian.terms\n        num_terms = len(terms)\n        num_qubits = circuit.num_qubits\n\n        coeffs_arr = (ctypes.c_double * num_terms)()\n        pauli_codes_arr = (ctypes.c_uint8 * (num_terms * num_qubits))()\n\n        # Init codes to 0 (Identity)\n        ctypes.memset(pauli_codes_arr, 0, ctypes.sizeof(pauli_codes_arr))\n\n        for i, term in enumerate(terms):\n            coeffs_arr[i] = term.coeff.real # Assume Hermitian/Real coeffs\n            for p_str, q_idx in term.ops:\n                code = 0\n                if p_str == 'X': code = 1\n                elif p_str == 'Y': code = 2\n                elif p_str == 'Z': code = 3\n                if q_idx &lt; num_qubits:\n                    pauli_codes_arr[i * num_qubits + q_idx] = code\n\n        h_struct = MQHamiltonian()\n        h_struct.num_terms = num_terms\n        h_struct.num_qubits = num_qubits\n        h_struct.coeffs = ctypes.cast(coeffs_arr, ctypes.POINTER(ctypes.c_double))\n        h_struct.pauli_codes = ctypes.cast(pauli_codes_arr, ctypes.POINTER(ctypes.c_uint8))\n\n        # 3. Output Buffer\n        # Calculate total number of parameters across all gates\n        total_param_count = sum(len(g.params) for g in circuit.gates)\n\n        # Allocate flat gradient buffer for all parameters\n        grads_out = (ctypes.c_double * total_param_count)()\n\n        res = self._lib.metalq_gradient_adjoint(\n            self._ctx,\n            ctypes.c_uint32(num_qubits),\n            c_gates,\n            ctypes.c_uint32(len(circuit.gates)),\n            ctypes.byref(h_struct),\n            grads_out\n        )\n\n        if res != 0:\n            raise RuntimeError(f\"Native adjoint gradient failed with code {res}\")\n\n        # 4. Filter/Map Gradients\n        # Map flat gradients back to input parameter structure.\n        # We walk through gates and consume gradients from the flat buffer.\n\n        final_grads = []\n        grad_ptr = 0\n\n        for gate in circuit.gates:\n            num_params_gate = len(gate.params)\n\n            if num_params_gate &gt; 0:\n                # Extract gradients for this gate\n                # For v1 standard gates (RX, RY, RZ), usually 1 param.\n                # If multi-param gate (e.g. U3), we extract all.\n\n                # Check if this gate corresponds to trainable parameters in the input list.\n                # Simplification: We assume the input `params` list strictly corresponds \n                # to the sequence of parameters encountered in circuit traversal.\n                # (i.e., we return ALL computed gradients).\n\n                for k in range(num_params_gate):\n                    final_grads.append(grads_out[grad_ptr + k])\n\n            grad_ptr += num_params_gate\n\n        return np.array(final_grads)\n</code></pre>"},{"location":"api/backends/#metalq.backends.mps.MPSBackend.__del__","title":"<code>__del__()</code>","text":"<p>Cleanup native resources.</p> Source code in <code>metalq/backends/mps/backend.py</code> <pre><code>def __del__(self):\n    \"\"\"Cleanup native resources.\"\"\"\n    if hasattr(self, '_lib') and self._lib and hasattr(self, '_ctx') and self._ctx:\n        self._lib.metalq_destroy_context(self._ctx)\n</code></pre>"},{"location":"api/backends/#metalq.backends.mps.MPSBackend.__init__","title":"<code>__init__()</code>","text":"<p>Initialize MPS backend.</p> Source code in <code>metalq/backends/mps/backend.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize MPS backend.\"\"\"\n    self._lib = self._load_library()\n    self._lib = self._load_library()\n\n    # Check if building documentation or running on non-macOS\n    if not self._lib:\n        if os.environ.get('METALQ_DOCS_BUILD') == '1' or os.environ.get('READTHEDOCS') == 'True':\n            # Create a mock library for documentation build\n            class MockLib:\n                def __getattr__(self, name):\n                    return ctypes.CFUNCTYPE(None) \n                def metalq_create_context(self): return ctypes.c_void_p(1)\n                def metalq_is_supported(self): return True\n                def metalq_destroy_context(self, ctx): pass\n                def metalq_run(self, *args): return 0\n                def metalq_gradient_adjoint(self, *args): return 0\n\n            self._lib = MockLib()\n        else:\n            raise RuntimeError(\"Failed to load native MetalQ library\")\n\n    # Define function signatures\n    self._lib.metalq_create_context.restype = ctypes.c_void_p\n    self._lib.metalq_is_supported.restype = ctypes.c_bool\n\n    self._lib.metalq_destroy_context.argtypes = [ctypes.c_void_p]\n    self._lib.metalq_run.argtypes = [\n        ctypes.c_void_p,\n        ctypes.c_uint32,\n        ctypes.POINTER(MQGate),\n        ctypes.c_uint32,\n        ctypes.c_uint32,\n        ctypes.POINTER(MQComplex),\n        ctypes.POINTER(ctypes.c_uint64)\n    ]\n\n    self._lib.metalq_gradient_adjoint.argtypes = [\n        ctypes.c_void_p,\n        ctypes.c_uint32,\n        ctypes.POINTER(MQGate),\n        ctypes.c_uint32,\n        ctypes.c_void_p, # MQHamiltonian*\n        ctypes.POINTER(ctypes.c_double)\n    ]\n\n    # Initialize native context\n    self._ctx = self._lib.metalq_create_context()\n    if not self._ctx:\n        raise RuntimeError(\"Failed to create MetalQ context\")\n</code></pre>"},{"location":"api/backends/#metalq.backends.mps.MPSBackend.is_available","title":"<code>is_available()</code>","text":"<p>Check if Metal is supported on this device.</p> Source code in <code>metalq/backends/mps/backend.py</code> <pre><code>def is_available(self) -&gt; bool:\n    \"\"\"Check if Metal is supported on this device.\"\"\"\n    if not self._lib: return False\n    return bool(self._lib.metalq_is_supported())\n</code></pre>"},{"location":"api/backends/#metalq.backends.mps.MPSBackend.run","title":"<code>run(circuit, shots=0, params=None)</code>","text":"<p>Execute circuit on GPU.</p> Source code in <code>metalq/backends/mps/backend.py</code> <pre><code>def run(self, \n        circuit: 'Circuit', \n        shots: int = 0,\n        params: Optional[Union[Dict, List[float]]] = None) -&gt; Dict:\n    \"\"\"Execute circuit on GPU.\"\"\"\n\n    # Bind parameters\n    if params is not None:\n        circuit = circuit.bind_parameters(params)\n\n    num_qubits = circuit.num_qubits\n\n    # Convert gates to C structure\n    c_gates = (MQGate * len(circuit.gates))()\n\n    for i, gate in enumerate(circuit.gates):\n        gt = c_gates[i]\n\n        # Map name to ID\n        gname = gate.name.lower()\n\n        if gname in GATE_MAP:\n            gt.type = GATE_MAP[gname]\n            # Copy params directly\n            gt.num_params = len(gate.params)\n            for j, p in enumerate(gate.params):\n                if j &lt; 3: gt.params[j] = float(p)\n\n        # Decompositions / Mappings\n        elif gname == 'sdg':\n            gt.type = GATE_MAP['p']\n            gt.num_params = 1\n            gt.params[0] = -np.pi/2\n        elif gname == 'tdg':\n            gt.type = GATE_MAP['p']\n            gt.num_params = 1\n            gt.params[0] = -np.pi/4\n        elif gname == 'sx':\n            gt.type = GATE_MAP['rx']\n            gt.num_params = 1\n            gt.params[0] = np.pi/2\n        elif gname == 'sxdg':\n            gt.type = GATE_MAP['rx']\n            gt.num_params = 1\n            gt.params[0] = -np.pi/2\n\n        else:\n            # Fallback or error? For MVP, skip or error.\n            print(f\"Warning: Unsupported gate {gname} for MPS, skipping/mapping to identity.\")\n            gt.type = 999 \n\n        # Qubits\n        gt.num_qubits = len(gate.qubits)\n        for j, q in enumerate(gate.qubits):\n            if j &lt; 3: gt.qubits[j] = q\n\n\n    # Allocate output buffers\n    # Statevector: 2^n * 8 bytes (float complex)\n    sv_size = 1 &lt;&lt; num_qubits\n    statevector = np.zeros(sv_size, dtype=np.complex64)\n\n    # We need to pass pointer to numpy data\n    sv_ptr = statevector.ctypes.data_as(ctypes.POINTER(MQComplex))\n\n    # Measurement counts (if shots &gt; 0)\n    # Native API signature:\n    # int metalq_run(ctx, nq, gates, ng, shots, sv_out, counts_out)\n\n    # Counts logic in native is not fully implemented in verify/plan, \n    # but let's assume we get statevector back and sample in Python for MVP if shots&gt;0\n    # for maximum reliability in Phase 2/3 transition.\n    # Or pass explicit None.\n\n    # print(f\"DEBUG: Calling metalq_run with {num_qubits} qubits, {len(circuit.gates)} gates\")\n    res_code = self._lib.metalq_run(\n        self._ctx,\n        ctypes.c_uint32(num_qubits),\n        c_gates,\n        ctypes.c_uint32(len(circuit.gates)),\n        ctypes.c_uint32(0), # shots=0 for now in native to just get SV\n        sv_ptr,\n        None # counts out\n    )\n    # print(f\"DEBUG: metalq_run returned {res_code}\")\n\n    if res_code != 0:\n        raise RuntimeError(f\"Metal execution failed with code {res_code}\")\n\n    result = {}\n    result['statevector'] = statevector\n\n    # If shots requested, sample from statevector on CPU for now (hybrid)\n    # Implementing full GPU sampling is an optimization.\n    if shots &gt; 0:\n        from ..cpu.measurement import sample_counts\n        result['counts'] = sample_counts(statevector, shots, num_qubits)\n\n    return result\n</code></pre>"},{"location":"api/backends/#cpubackend","title":"CPUBackend","text":"<p>               Bases: <code>Backend</code></p> <p>High-performance CPU backend using NumPy, Numba, and Polars.</p> <p>\u6700\u9069\u5316\u6226\u7565: - NumPy: \u30d9\u30af\u30c8\u30eb\u5316\u3055\u308c\u305f\u914d\u5217\u6f14\u7b97 - Numba: JIT\u30b3\u30f3\u30d1\u30a4\u30eb\u3067\u30b2\u30fc\u30c8\u9069\u7528\u3092\u9ad8\u901f\u5316 - Polars: \u4e26\u5217\u96c6\u8a08\u3067\u6e2c\u5b9a\u7d50\u679c\u51e6\u7406\u3092\u9ad8\u901f\u5316</p> Source code in <code>metalq/backends/cpu/backend.py</code> <pre><code>class CPUBackend(Backend):\n    \"\"\"\n    High-performance CPU backend using NumPy, Numba, and Polars.\n\n    \u6700\u9069\u5316\u6226\u7565:\n    - NumPy: \u30d9\u30af\u30c8\u30eb\u5316\u3055\u308c\u305f\u914d\u5217\u6f14\u7b97\n    - Numba: JIT\u30b3\u30f3\u30d1\u30a4\u30eb\u3067\u30b2\u30fc\u30c8\u9069\u7528\u3092\u9ad8\u901f\u5316\n    - Polars: \u4e26\u5217\u96c6\u8a08\u3067\u6e2c\u5b9a\u7d50\u679c\u51e6\u7406\u3092\u9ad8\u901f\u5316\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize CPU backend.\"\"\"\n        self._check_dependencies()\n\n    def _check_dependencies(self):\n        \"\"\"Check and import optional dependencies.\"\"\"\n        # Numba (optional but recommended)\n        try:\n            import numba\n            self._has_numba = True\n        except ImportError:\n            self._has_numba = False\n            # import warnings\n            # warnings.warn(\n            #     \"Numba not found. Install with 'pip install numba' for 2-5x speedup.\"\n            # )\n\n        # Polars (optional but recommended)\n        try:\n            import polars\n            self._has_polars = True\n        except ImportError:\n            self._has_polars = False\n\n    @property\n    def name(self) -&gt; str:\n        return 'cpu'\n\n    @property\n    def max_qubits(self) -&gt; int:\n        \"\"\"\n        Maximum qubits based on available memory.\n\n        State vector size = 2^n * 16 bytes (complex128)\n        \"\"\"\n        try:\n            import psutil\n            available_memory = psutil.virtual_memory().available\n        except ImportError:\n            # Fallback if psutil not installed\n            available_memory = 8 * 1024**3  # Assume 8GB\n\n        # Use at most 75% of available memory\n        max_memory = available_memory * 0.75\n\n        # Solve: 2^n * 16 &lt; max_memory\n        import math\n        max_n = int(math.log2(max_memory / 16))\n\n        return min(max_n, 30)  # Cap at 30 qubits\n\n    # ========================================================================\n    # Main Execution Methods\n    # ========================================================================\n\n    def run(self, \n            circuit: 'Circuit', \n            shots: int = 0,\n            params: Optional[Union[Dict, List[float]]] = None) -&gt; Dict:\n        \"\"\"Execute circuit.\"\"\"\n        start_time = time.perf_counter()\n\n        # Bind parameters if needed\n        if params is not None:\n            circuit = circuit.bind_parameters(params)\n\n        # Get statevector\n        sv = self.statevector(circuit)\n\n        result = {'time_ms': 0.0}\n\n        if shots == 0:\n            result['statevector'] = sv\n        else:\n            # Sample measurements\n            from .measurement import sample_counts\n            result['counts'] = sample_counts(\n                sv, \n                shots, \n                circuit.num_qubits,\n                use_polars=self._has_polars\n            )\n\n        result['time_ms'] = (time.perf_counter() - start_time) * 1000\n        return result\n\n    def statevector(self, \n                    circuit: 'Circuit',\n                    params: Optional[Union[Dict, List[float]]] = None) -&gt; np.ndarray:\n        \"\"\"Compute final statevector.\"\"\"\n        # Bind parameters\n        if params is not None:\n            circuit = circuit.bind_parameters(params)\n\n        # Initialize |0...0\u27e9\n        from .statevector import initialize_statevector, apply_gates\n        sv = initialize_statevector(circuit.num_qubits)\n\n        # Apply gates\n        if self._has_numba:\n            from .gates import apply_gates_numba\n            sv = apply_gates_numba(sv, circuit._gates, circuit.num_qubits)\n        else:\n            sv = apply_gates(sv, circuit._gates, circuit.num_qubits)\n\n        return sv\n\n    def expectation(self, \n                    circuit: 'Circuit', \n                    hamiltonian: 'Hamiltonian',\n                    params: Optional[Union[Dict, List[float]]] = None) -&gt; float:\n        \"\"\"Compute expectation value.\"\"\"\n        sv = self.statevector(circuit, params)\n\n        # &lt;\u03c8|H|\u03c8&gt; = \u03c8\u2020 H \u03c8\n        n = circuit.num_qubits\n        H_matrix = hamiltonian.to_matrix(n)\n\n        # Use efficient conjugate transpose\n        expectation = np.real(np.vdot(sv, H_matrix @ sv))\n\n        return float(expectation)\n\n    def gradient(self, \n                 circuit: 'Circuit', \n                 hamiltonian: 'Hamiltonian',\n                 params: List[float],\n                 method: str = 'parameter_shift') -&gt; np.ndarray:\n        \"\"\"Compute gradient using parameter-shift rule.\"\"\"\n        from .gradient import parameter_shift_gradient\n\n        return parameter_shift_gradient(\n            self, circuit, hamiltonian, params\n        )\n</code></pre>"},{"location":"api/backends/#metalq.backends.cpu.CPUBackend.max_qubits","title":"<code>max_qubits</code>  <code>property</code>","text":"<p>Maximum qubits based on available memory.</p> <p>State vector size = 2^n * 16 bytes (complex128)</p>"},{"location":"api/backends/#metalq.backends.cpu.CPUBackend.__init__","title":"<code>__init__()</code>","text":"<p>Initialize CPU backend.</p> Source code in <code>metalq/backends/cpu/backend.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize CPU backend.\"\"\"\n    self._check_dependencies()\n</code></pre>"},{"location":"api/backends/#metalq.backends.cpu.CPUBackend.expectation","title":"<code>expectation(circuit, hamiltonian, params=None)</code>","text":"<p>Compute expectation value.</p> Source code in <code>metalq/backends/cpu/backend.py</code> <pre><code>def expectation(self, \n                circuit: 'Circuit', \n                hamiltonian: 'Hamiltonian',\n                params: Optional[Union[Dict, List[float]]] = None) -&gt; float:\n    \"\"\"Compute expectation value.\"\"\"\n    sv = self.statevector(circuit, params)\n\n    # &lt;\u03c8|H|\u03c8&gt; = \u03c8\u2020 H \u03c8\n    n = circuit.num_qubits\n    H_matrix = hamiltonian.to_matrix(n)\n\n    # Use efficient conjugate transpose\n    expectation = np.real(np.vdot(sv, H_matrix @ sv))\n\n    return float(expectation)\n</code></pre>"},{"location":"api/backends/#metalq.backends.cpu.CPUBackend.gradient","title":"<code>gradient(circuit, hamiltonian, params, method='parameter_shift')</code>","text":"<p>Compute gradient using parameter-shift rule.</p> Source code in <code>metalq/backends/cpu/backend.py</code> <pre><code>def gradient(self, \n             circuit: 'Circuit', \n             hamiltonian: 'Hamiltonian',\n             params: List[float],\n             method: str = 'parameter_shift') -&gt; np.ndarray:\n    \"\"\"Compute gradient using parameter-shift rule.\"\"\"\n    from .gradient import parameter_shift_gradient\n\n    return parameter_shift_gradient(\n        self, circuit, hamiltonian, params\n    )\n</code></pre>"},{"location":"api/backends/#metalq.backends.cpu.CPUBackend.run","title":"<code>run(circuit, shots=0, params=None)</code>","text":"<p>Execute circuit.</p> Source code in <code>metalq/backends/cpu/backend.py</code> <pre><code>def run(self, \n        circuit: 'Circuit', \n        shots: int = 0,\n        params: Optional[Union[Dict, List[float]]] = None) -&gt; Dict:\n    \"\"\"Execute circuit.\"\"\"\n    start_time = time.perf_counter()\n\n    # Bind parameters if needed\n    if params is not None:\n        circuit = circuit.bind_parameters(params)\n\n    # Get statevector\n    sv = self.statevector(circuit)\n\n    result = {'time_ms': 0.0}\n\n    if shots == 0:\n        result['statevector'] = sv\n    else:\n        # Sample measurements\n        from .measurement import sample_counts\n        result['counts'] = sample_counts(\n            sv, \n            shots, \n            circuit.num_qubits,\n            use_polars=self._has_polars\n        )\n\n    result['time_ms'] = (time.perf_counter() - start_time) * 1000\n    return result\n</code></pre>"},{"location":"api/backends/#metalq.backends.cpu.CPUBackend.statevector","title":"<code>statevector(circuit, params=None)</code>","text":"<p>Compute final statevector.</p> Source code in <code>metalq/backends/cpu/backend.py</code> <pre><code>def statevector(self, \n                circuit: 'Circuit',\n                params: Optional[Union[Dict, List[float]]] = None) -&gt; np.ndarray:\n    \"\"\"Compute final statevector.\"\"\"\n    # Bind parameters\n    if params is not None:\n        circuit = circuit.bind_parameters(params)\n\n    # Initialize |0...0\u27e9\n    from .statevector import initialize_statevector, apply_gates\n    sv = initialize_statevector(circuit.num_qubits)\n\n    # Apply gates\n    if self._has_numba:\n        from .gates import apply_gates_numba\n        sv = apply_gates_numba(sv, circuit._gates, circuit.num_qubits)\n    else:\n        sv = apply_gates(sv, circuit._gates, circuit.num_qubits)\n\n    return sv\n</code></pre>"},{"location":"api/circuit/","title":"Circuit &amp; Construction","text":"<p>Core classes for defining quantum circuits and operators.</p>"},{"location":"api/circuit/#circuit","title":"Circuit","text":"<p>Quantum Circuit with Qiskit-like API.</p> <p>Attributes:</p> Name Type Description <code>num_qubits</code> <p>Number of qubits</p> <code>num_clbits</code> <p>Number of classical bits</p> Example <p>qc = Circuit(4) qc.h(0) qc.cx(0, 1) qc.cx(1, 2) qc.cx(2, 3) qc.measure_all()</p> <p>print(qc.draw())</p> Source code in <code>metalq/circuit.py</code> <pre><code>class Circuit:\n    \"\"\"\n    Quantum Circuit with Qiskit-like API.\n\n    Attributes:\n        num_qubits: Number of qubits\n        num_clbits: Number of classical bits\n\n    Example:\n        qc = Circuit(4)\n        qc.h(0)\n        qc.cx(0, 1)\n        qc.cx(1, 2)\n        qc.cx(2, 3)\n        qc.measure_all()\n\n        print(qc.draw())\n    \"\"\"\n\n    __slots__ = ('num_qubits', 'num_clbits', '_gates', '_measurements', '_parameters')\n\n    def __init__(self, num_qubits: int, num_clbits: Optional[int] = None):\n        \"\"\"\n        Initialize a quantum circuit.\n\n        Args:\n            num_qubits: Number of qubits\n            num_clbits: Number of classical bits (default: same as num_qubits)\n        \"\"\"\n        if num_qubits &lt;= 0:\n            raise ValueError(\"num_qubits must be positive\")\n\n        self.num_qubits = num_qubits\n        self.num_clbits = num_clbits if num_clbits is not None else num_qubits\n        self._gates: List[Gate] = []\n        self._measurements: List[Tuple[int, int]] = []  # (qubit, clbit)\n        self._parameters: Set[Parameter] = set()\n\n    # ========================================================================\n    # Single-Qubit Gates\n    # ========================================================================\n\n    def _validate_qubit(self, qubit: int, name: str = \"qubit\"):\n        \"\"\"Validate qubit index.\"\"\"\n        if not 0 &lt;= qubit &lt; self.num_qubits:\n            raise ValueError(f\"{name} {qubit} out of range [0, {self.num_qubits})\")\n\n    def _add_gate(self, name: str, qubits: List[int], \n                  params: Optional[List[Union[float, Parameter]]] = None) -&gt; Circuit:\n        \"\"\"Internal method to add a gate.\"\"\"\n        for q in qubits:\n            self._validate_qubit(q)\n\n        gate = Gate(name=name, qubits=qubits, params=params or [])\n        self._gates.append(gate)\n\n        # Track parameters\n        for p in (params or []):\n            self._parameters.update(get_parameters(p))\n\n        return self\n\n    def id(self, qubit: int) -&gt; Circuit:\n        \"\"\"Identity gate (no-op, useful for timing).\"\"\"\n        return self._add_gate('id', [qubit])\n\n    def x(self, qubit: int) -&gt; Circuit:\n        \"\"\"Pauli-X (NOT) gate.\"\"\"\n        return self._add_gate('x', [qubit])\n\n    def y(self, qubit: int) -&gt; Circuit:\n        \"\"\"Pauli-Y gate.\"\"\"\n        return self._add_gate('y', [qubit])\n\n    def z(self, qubit: int) -&gt; Circuit:\n        \"\"\"Pauli-Z gate.\"\"\"\n        return self._add_gate('z', [qubit])\n\n    def h(self, qubit: int) -&gt; Circuit:\n        \"\"\"Hadamard gate.\"\"\"\n        return self._add_gate('h', [qubit])\n\n    def s(self, qubit: int) -&gt; Circuit:\n        \"\"\"S gate (sqrt(Z), phase gate with \u03b8=\u03c0/2).\"\"\"\n        return self._add_gate('s', [qubit])\n\n    def sdg(self, qubit: int) -&gt; Circuit:\n        \"\"\"S-dagger gate (inverse of S).\"\"\"\n        return self._add_gate('sdg', [qubit])\n\n    def t(self, qubit: int) -&gt; Circuit:\n        \"\"\"T gate (sqrt(S), phase gate with \u03b8=\u03c0/4).\"\"\"\n        return self._add_gate('t', [qubit])\n\n    def tdg(self, qubit: int) -&gt; Circuit:\n        \"\"\"T-dagger gate (inverse of T).\"\"\"\n        return self._add_gate('tdg', [qubit])\n\n    def sx(self, qubit: int) -&gt; Circuit:\n        \"\"\"Sqrt(X) gate.\"\"\"\n        return self._add_gate('sx', [qubit])\n\n    def sxdg(self, qubit: int) -&gt; Circuit:\n        \"\"\"Sqrt(X)-dagger gate.\"\"\"\n        return self._add_gate('sxdg', [qubit])\n\n    # ========================================================================\n    # Rotation Gates (Parameterizable)\n    # ========================================================================\n\n    def rx(self, theta: Union[float, Parameter], qubit: int) -&gt; Circuit:\n        \"\"\"Rotation around X-axis by angle theta.\"\"\"\n        return self._add_gate('rx', [qubit], [theta])\n\n    def ry(self, theta: Union[float, Parameter], qubit: int) -&gt; Circuit:\n        \"\"\"Rotation around Y-axis by angle theta.\"\"\"\n        return self._add_gate('ry', [qubit], [theta])\n\n    def rz(self, theta: Union[float, Parameter], qubit: int) -&gt; Circuit:\n        \"\"\"Rotation around Z-axis by angle theta.\"\"\"\n        return self._add_gate('rz', [qubit], [theta])\n\n    def p(self, theta: Union[float, Parameter], qubit: int) -&gt; Circuit:\n        \"\"\"Phase gate (rotation around Z with global phase).\"\"\"\n        return self._add_gate('p', [qubit], [theta])\n\n    def u(self, theta: Union[float, Parameter], \n          phi: Union[float, Parameter], \n          lam: Union[float, Parameter], \n          qubit: int) -&gt; Circuit:\n        \"\"\"\n        Universal single-qubit gate U(\u03b8, \u03c6, \u03bb).\n\n        U(\u03b8, \u03c6, \u03bb) = [[cos(\u03b8/2), -e^(i\u03bb)sin(\u03b8/2)],\n                      [e^(i\u03c6)sin(\u03b8/2), e^(i(\u03c6+\u03bb))cos(\u03b8/2)]]\n        \"\"\"\n        return self._add_gate('u', [qubit], [theta, phi, lam])\n\n    def u1(self, lam: Union[float, Parameter], qubit: int) -&gt; Circuit:\n        \"\"\"U1 gate (equivalent to p gate).\"\"\"\n        return self._add_gate('u1', [qubit], [lam])\n\n    def u2(self, phi: Union[float, Parameter], \n           lam: Union[float, Parameter], qubit: int) -&gt; Circuit:\n        \"\"\"U2 gate.\"\"\"\n        return self._add_gate('u2', [qubit], [phi, lam])\n\n    def u3(self, theta: Union[float, Parameter], \n           phi: Union[float, Parameter], \n           lam: Union[float, Parameter], \n           qubit: int) -&gt; Circuit:\n        \"\"\"U3 gate (same as u).\"\"\"\n        return self._add_gate('u3', [qubit], [theta, phi, lam])\n\n    def r(self, theta: Union[float, Parameter], \n          phi: Union[float, Parameter], qubit: int) -&gt; Circuit:\n        \"\"\"Rotation gate R(\u03b8, \u03c6) = exp(-i \u03b8/2 (cos(\u03c6)X + sin(\u03c6)Y)).\"\"\"\n        return self._add_gate('r', [qubit], [theta, phi])\n\n    # ========================================================================\n    # Two-Qubit Gates\n    # ========================================================================\n\n    def cx(self, control: int, target: int) -&gt; Circuit:\n        \"\"\"CNOT (Controlled-X) gate.\"\"\"\n        return self._add_gate('cx', [control, target])\n\n    def cnot(self, control: int, target: int) -&gt; Circuit:\n        \"\"\"Alias for cx.\"\"\"\n        return self.cx(control, target)\n\n    def cy(self, control: int, target: int) -&gt; Circuit:\n        \"\"\"Controlled-Y gate.\"\"\"\n        return self._add_gate('cy', [control, target])\n\n    def cz(self, control: int, target: int) -&gt; Circuit:\n        \"\"\"Controlled-Z gate.\"\"\"\n        return self._add_gate('cz', [control, target])\n\n    def ch(self, control: int, target: int) -&gt; Circuit:\n        \"\"\"Controlled-Hadamard gate.\"\"\"\n        return self._add_gate('ch', [control, target])\n\n    def cs(self, control: int, target: int) -&gt; Circuit:\n        \"\"\"Controlled-S gate.\"\"\"\n        return self._add_gate('cs', [control, target])\n\n    def csdg(self, control: int, target: int) -&gt; Circuit:\n        \"\"\"Controlled-S-dagger gate.\"\"\"\n        return self._add_gate('csdg', [control, target])\n\n    def csx(self, control: int, target: int) -&gt; Circuit:\n        \"\"\"Controlled-Sqrt(X) gate.\"\"\"\n        return self._add_gate('csx', [control, target])\n\n    def swap(self, qubit1: int, qubit2: int) -&gt; Circuit:\n        \"\"\"SWAP gate.\"\"\"\n        return self._add_gate('swap', [qubit1, qubit2])\n\n    def iswap(self, qubit1: int, qubit2: int) -&gt; Circuit:\n        \"\"\"iSWAP gate.\"\"\"\n        return self._add_gate('iswap', [qubit1, qubit2])\n\n    def dcx(self, qubit1: int, qubit2: int) -&gt; Circuit:\n        \"\"\"Double CNOT gate (DCX).\"\"\"\n        return self._add_gate('dcx', [qubit1, qubit2])\n\n    def ecr(self, qubit1: int, qubit2: int) -&gt; Circuit:\n        \"\"\"Echoed Cross-Resonance gate.\"\"\"\n        return self._add_gate('ecr', [qubit1, qubit2])\n\n    # Controlled rotations\n    def crx(self, theta: Union[float, Parameter], control: int, target: int) -&gt; Circuit:\n        \"\"\"Controlled-RX gate.\"\"\"\n        return self._add_gate('crx', [control, target], [theta])\n\n    def cry(self, theta: Union[float, Parameter], control: int, target: int) -&gt; Circuit:\n        \"\"\"Controlled-RY gate.\"\"\"\n        return self._add_gate('cry', [control, target], [theta])\n\n    def crz(self, theta: Union[float, Parameter], control: int, target: int) -&gt; Circuit:\n        \"\"\"Controlled-RZ gate.\"\"\"\n        return self._add_gate('crz', [control, target], [theta])\n\n    def cp(self, theta: Union[float, Parameter], control: int, target: int) -&gt; Circuit:\n        \"\"\"Controlled-Phase gate.\"\"\"\n        return self._add_gate('cp', [control, target], [theta])\n\n    def cu(self, theta: Union[float, Parameter], \n           phi: Union[float, Parameter], \n           lam: Union[float, Parameter], \n           gamma: Union[float, Parameter],\n           control: int, target: int) -&gt; Circuit:\n        \"\"\"Controlled-U gate with global phase.\"\"\"\n        return self._add_gate('cu', [control, target], [theta, phi, lam, gamma])\n\n    def cu1(self, lam: Union[float, Parameter], control: int, target: int) -&gt; Circuit:\n        \"\"\"Controlled-U1 gate.\"\"\"\n        return self._add_gate('cu1', [control, target], [lam])\n\n    def cu3(self, theta: Union[float, Parameter], \n            phi: Union[float, Parameter], \n            lam: Union[float, Parameter],\n            control: int, target: int) -&gt; Circuit:\n        \"\"\"Controlled-U3 gate.\"\"\"\n        return self._add_gate('cu3', [control, target], [theta, phi, lam])\n\n    # Ising coupling gates\n    def rxx(self, theta: Union[float, Parameter], qubit1: int, qubit2: int) -&gt; Circuit:\n        \"\"\"RXX (Ising XX coupling) gate.\"\"\"\n        return self._add_gate('rxx', [qubit1, qubit2], [theta])\n\n    def ryy(self, theta: Union[float, Parameter], qubit1: int, qubit2: int) -&gt; Circuit:\n        \"\"\"RYY (Ising YY coupling) gate.\"\"\"\n        return self._add_gate('ryy', [qubit1, qubit2], [theta])\n\n    def rzz(self, theta: Union[float, Parameter], qubit1: int, qubit2: int) -&gt; Circuit:\n        \"\"\"RZZ (Ising ZZ coupling) gate.\"\"\"\n        return self._add_gate('rzz', [qubit1, qubit2], [theta])\n\n    def rzx(self, theta: Union[float, Parameter], qubit1: int, qubit2: int) -&gt; Circuit:\n        \"\"\"RZX gate.\"\"\"\n        return self._add_gate('rzx', [qubit1, qubit2], [theta])\n\n    # ========================================================================\n    # Three-Qubit Gates\n    # ========================================================================\n\n    def ccx(self, control1: int, control2: int, target: int) -&gt; Circuit:\n        \"\"\"Toffoli (CCX) gate.\"\"\"\n        return self._add_gate('ccx', [control1, control2, target])\n\n    def toffoli(self, control1: int, control2: int, target: int) -&gt; Circuit:\n        \"\"\"Alias for ccx.\"\"\"\n        return self.ccx(control1, control2, target)\n\n    def cswap(self, control: int, target1: int, target2: int) -&gt; Circuit:\n        \"\"\"Fredkin (CSWAP) gate.\"\"\"\n        return self._add_gate('cswap', [control, target1, target2])\n\n    def fredkin(self, control: int, target1: int, target2: int) -&gt; Circuit:\n        \"\"\"Alias for cswap.\"\"\"\n        return self.cswap(control, target1, target2)\n\n    def ccz(self, qubit1: int, qubit2: int, qubit3: int) -&gt; Circuit:\n        \"\"\"CCZ gate.\"\"\"\n        return self._add_gate('ccz', [qubit1, qubit2, qubit3])\n\n    # ========================================================================\n    # Measurement\n    # ========================================================================\n\n    def measure(self, qubit: int, clbit: int) -&gt; Circuit:\n        \"\"\"\n        Measure a qubit into a classical bit.\n\n        Args:\n            qubit: Qubit index to measure\n            clbit: Classical bit to store result\n        \"\"\"\n        self._validate_qubit(qubit)\n        if not 0 &lt;= clbit &lt; self.num_clbits:\n            raise ValueError(f\"clbit {clbit} out of range [0, {self.num_clbits})\")\n\n        self._measurements.append((qubit, clbit))\n        return self\n\n    def measure_all(self) -&gt; Circuit:\n        \"\"\"Measure all qubits into corresponding classical bits.\"\"\"\n        for i in range(min(self.num_qubits, self.num_clbits)):\n            self._measurements.append((i, i))\n        return self\n\n    # ========================================================================\n    # Barrier (for visualization/optimization hints)\n    # ========================================================================\n\n    def barrier(self, *qubits: int) -&gt; Circuit:\n        \"\"\"\n        Add a barrier (visual separator, optimization boundary).\n\n        Args:\n            *qubits: Qubits to include in barrier. If empty, all qubits.\n        \"\"\"\n        if not qubits:\n            qubits = tuple(range(self.num_qubits))\n        return self._add_gate('barrier', list(qubits))\n\n    # ========================================================================\n    # Parameter Binding\n    # ========================================================================\n\n    @property\n    def parameters(self) -&gt; List[Parameter]:\n        \"\"\"Get list of unbound parameters (in order of first appearance).\"\"\"\n        seen = set()\n        ordered = []\n        for gate in self._gates:\n            for p in gate.params:\n                for param in get_parameters(p):\n                    if param not in seen:\n                        seen.add(param)\n                        ordered.append(param)\n        return ordered\n\n    @property\n    def num_parameters(self) -&gt; int:\n        \"\"\"Get number of unique parameters.\"\"\"\n        return len(self._parameters)\n\n    def bind_parameters(self, \n                        params: Union[Dict[Parameter, float], List[float]]) -&gt; Circuit:\n        \"\"\"\n        Bind parameter values to create a concrete circuit.\n\n        Args:\n            params: Dict mapping Parameters to values, or list of values\n                    (in order of self.parameters)\n\n        Returns:\n            New circuit with bound parameters\n\n        Example:\n            theta = Parameter('\u03b8')\n            qc = Circuit(1).ry(theta, 0)\n\n            # Dict binding\n            bound = qc.bind_parameters({theta: 0.5})\n\n            # List binding\n            bound = qc.bind_parameters([0.5])\n        \"\"\"\n        from .parameter import evaluate_parameter\n\n        # Convert list to dict\n        if isinstance(params, (list, tuple)):\n            param_list = self.parameters\n            if len(params) != len(param_list):\n                raise ValueError(\n                    f\"Expected {len(param_list)} parameters, got {len(params)}\"\n                )\n            params = dict(zip(param_list, params))\n\n        # Create new circuit\n        new_circuit = Circuit(self.num_qubits, self.num_clbits)\n        new_circuit._measurements = self._measurements.copy()\n\n        # Bind each gate's parameters\n        for gate in self._gates:\n            new_params = []\n            for p in gate.params:\n                if is_parameterized(p):\n                    new_params.append(evaluate_parameter(p, params))\n                else:\n                    new_params.append(p)\n\n            new_circuit._gates.append(Gate(\n                name=gate.name,\n                qubits=gate.qubits.copy(),\n                params=new_params\n            ))\n\n        return new_circuit\n\n    # ========================================================================\n    # Properties\n    # ========================================================================\n\n    @property\n    def depth(self) -&gt; int:\n        \"\"\"\n        Calculate circuit depth (critical path length).\n\n        Returns:\n            Number of layers in the circuit\n        \"\"\"\n        if not self._gates:\n            return 0\n\n        qubit_depths = [0] * self.num_qubits\n\n        for gate in self._gates:\n            if gate.name == 'barrier':\n                continue\n\n            # Gate depth is max of all involved qubits + 1\n            max_depth = max(qubit_depths[q] for q in gate.qubits)\n            new_depth = max_depth + 1\n\n            for q in gate.qubits:\n                qubit_depths[q] = new_depth\n\n        return max(qubit_depths) if qubit_depths else 0\n\n    @property\n    def size(self) -&gt; int:\n        \"\"\"Get total number of gates (excluding barriers).\"\"\"\n        return sum(1 for g in self._gates if g.name != 'barrier')\n\n    @property\n    def gates(self) -&gt; List[Gate]:\n        \"\"\"Get list of gates (read-only copy).\"\"\"\n        return self._gates.copy()\n\n    @property\n    def measurements(self) -&gt; List[Tuple[int, int]]:\n        \"\"\"Get list of measurements (qubit, clbit) pairs.\"\"\"\n        return self._measurements.copy()\n\n    def has_measurements(self) -&gt; bool:\n        \"\"\"Check if circuit has any measurements.\"\"\"\n        return len(self._measurements) &gt; 0\n\n    # ========================================================================\n    # Utility Methods\n    # ========================================================================\n\n    def copy(self) -&gt; Circuit:\n        \"\"\"Create a deep copy of this circuit.\"\"\"\n        new_circuit = Circuit(self.num_qubits, self.num_clbits)\n        new_circuit._gates = [\n            Gate(g.name, g.qubits.copy(), g.params.copy()) \n            for g in self._gates\n        ]\n        new_circuit._measurements = self._measurements.copy()\n        new_circuit._parameters = self._parameters.copy()\n        return new_circuit\n\n    def inverse(self) -&gt; Circuit:\n        \"\"\"\n        Return the inverse (adjoint) of this circuit.\n\n        Returns:\n            New circuit with gates in reverse order and inverted\n        \"\"\"\n        new_circuit = Circuit(self.num_qubits, self.num_clbits)\n\n        for gate in reversed(self._gates):\n            inv_gate = self._invert_gate(gate)\n            new_circuit._gates.append(inv_gate)\n\n        new_circuit._parameters = self._parameters.copy()\n        return new_circuit\n\n    def _invert_gate(self, gate: Gate) -&gt; Gate:\n        \"\"\"Get the inverse of a gate.\"\"\"\n        name = gate.name\n\n        # Self-inverse gates\n        if name in {'x', 'y', 'z', 'h', 'cx', 'cy', 'cz', 'swap', 'ccx', 'ccz', 'cswap', 'barrier'}:\n            return Gate(name, gate.qubits.copy(), gate.params.copy())\n\n        # S &lt;-&gt; Sdg, T &lt;-&gt; Tdg\n        inverse_map = {\n            's': 'sdg', 'sdg': 's',\n            't': 'tdg', 'tdg': 't',\n            'sx': 'sxdg', 'sxdg': 'sx',\n        }\n        if name in inverse_map:\n            return Gate(inverse_map[name], gate.qubits.copy(), [])\n\n        # Rotation gates: negate angle\n        if name in {'rx', 'ry', 'rz', 'p', 'u1', 'crx', 'cry', 'crz', 'cp', 'rxx', 'ryy', 'rzz', 'rzx'}:\n            new_params = [-p for p in gate.params]\n            return Gate(name, gate.qubits.copy(), new_params)\n\n        # U gate: more complex inversion\n        if name in {'u', 'u3', 'cu', 'cu3'}:\n            # U\u2020(\u03b8,\u03c6,\u03bb) = U(-\u03b8, -\u03bb, -\u03c6)\n            theta, phi, lam = gate.params[:3]\n            new_params = [-theta, -lam, -phi] + gate.params[3:]\n            return Gate(name, gate.qubits.copy(), new_params)\n\n        # Default: return as-is (may not be correct for all gates)\n        return Gate(name, gate.qubits.copy(), gate.params.copy())\n\n    def compose(self, other: Circuit, inplace: bool = False) -&gt; Circuit:\n        \"\"\"\n        Compose with another circuit (append other's gates).\n\n        Args:\n            other: Circuit to append\n            inplace: If True, modify this circuit\n\n        Returns:\n            Composed circuit\n        \"\"\"\n        if other.num_qubits != self.num_qubits:\n            raise ValueError(\n                f\"Cannot compose circuits with different qubit counts: \"\n                f\"{self.num_qubits} vs {other.num_qubits}\"\n            )\n\n        if inplace:\n            result = self\n        else:\n            result = self.copy()\n\n        result._gates.extend(g for g in other._gates)\n        result._measurements.extend(other._measurements)\n        result._parameters.update(other._parameters)\n\n        return result\n\n    def __add__(self, other: Circuit) -&gt; Circuit:\n        \"\"\"Compose circuits using + operator.\"\"\"\n        return self.compose(other)\n\n    def __iadd__(self, other: Circuit) -&gt; Circuit:\n        \"\"\"In-place compose using += operator.\"\"\"\n        return self.compose(other, inplace=True)\n\n    # ========================================================================\n    # Serialization\n    # ========================================================================\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Convert circuit to dictionary for serialization.\n\n        Used for passing to native backend.\n        \"\"\"\n        return {\n            'num_qubits': self.num_qubits,\n            'num_clbits': self.num_clbits,\n            'gates': [g.to_dict() for g in self._gates],\n            'measurements': self._measurements,\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; Circuit:\n        \"\"\"Create circuit from dictionary.\"\"\"\n        circuit = cls(data['num_qubits'], data.get('num_clbits'))\n\n        for g in data['gates']:\n            circuit._gates.append(Gate(\n                name=g['name'],\n                qubits=g['qubits'],\n                params=g.get('params', [])\n            ))\n\n        circuit._measurements = [tuple(m) for m in data.get('measurements', [])]\n        return circuit\n\n    # ========================================================================\n    # String Representation\n    # ========================================================================\n\n    def __repr__(self) -&gt; str:\n        return (f\"Circuit(qubits={self.num_qubits}, \"\n                f\"gates={self.size}, depth={self.depth})\")\n\n    def __str__(self) -&gt; str:\n        return self.draw()\n\n    def draw(self, output: str = 'text') -&gt; str:\n        \"\"\"\n        Draw the circuit.\n\n        Args:\n            output: 'text' for ASCII art, 'latex' for LaTeX source\n\n        Returns:\n            String representation of the circuit\n        \"\"\"\n        from .visualization import draw_circuit\n        return draw_circuit(self, output=output)\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.depth","title":"<code>depth</code>  <code>property</code>","text":"<p>Calculate circuit depth (critical path length).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of layers in the circuit</p>"},{"location":"api/circuit/#metalq.Circuit.gates","title":"<code>gates</code>  <code>property</code>","text":"<p>Get list of gates (read-only copy).</p>"},{"location":"api/circuit/#metalq.Circuit.measurements","title":"<code>measurements</code>  <code>property</code>","text":"<p>Get list of measurements (qubit, clbit) pairs.</p>"},{"location":"api/circuit/#metalq.Circuit.num_parameters","title":"<code>num_parameters</code>  <code>property</code>","text":"<p>Get number of unique parameters.</p>"},{"location":"api/circuit/#metalq.Circuit.parameters","title":"<code>parameters</code>  <code>property</code>","text":"<p>Get list of unbound parameters (in order of first appearance).</p>"},{"location":"api/circuit/#metalq.Circuit.size","title":"<code>size</code>  <code>property</code>","text":"<p>Get total number of gates (excluding barriers).</p>"},{"location":"api/circuit/#metalq.Circuit.__add__","title":"<code>__add__(other)</code>","text":"<p>Compose circuits using + operator.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def __add__(self, other: Circuit) -&gt; Circuit:\n    \"\"\"Compose circuits using + operator.\"\"\"\n    return self.compose(other)\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.__iadd__","title":"<code>__iadd__(other)</code>","text":"<p>In-place compose using += operator.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def __iadd__(self, other: Circuit) -&gt; Circuit:\n    \"\"\"In-place compose using += operator.\"\"\"\n    return self.compose(other, inplace=True)\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.__init__","title":"<code>__init__(num_qubits, num_clbits=None)</code>","text":"<p>Initialize a quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>num_qubits</code> <code>int</code> <p>Number of qubits</p> required <code>num_clbits</code> <code>Optional[int]</code> <p>Number of classical bits (default: same as num_qubits)</p> <code>None</code> Source code in <code>metalq/circuit.py</code> <pre><code>def __init__(self, num_qubits: int, num_clbits: Optional[int] = None):\n    \"\"\"\n    Initialize a quantum circuit.\n\n    Args:\n        num_qubits: Number of qubits\n        num_clbits: Number of classical bits (default: same as num_qubits)\n    \"\"\"\n    if num_qubits &lt;= 0:\n        raise ValueError(\"num_qubits must be positive\")\n\n    self.num_qubits = num_qubits\n    self.num_clbits = num_clbits if num_clbits is not None else num_qubits\n    self._gates: List[Gate] = []\n    self._measurements: List[Tuple[int, int]] = []  # (qubit, clbit)\n    self._parameters: Set[Parameter] = set()\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.barrier","title":"<code>barrier(*qubits)</code>","text":"<p>Add a barrier (visual separator, optimization boundary).</p> <p>Parameters:</p> Name Type Description Default <code>*qubits</code> <code>int</code> <p>Qubits to include in barrier. If empty, all qubits.</p> <code>()</code> Source code in <code>metalq/circuit.py</code> <pre><code>def barrier(self, *qubits: int) -&gt; Circuit:\n    \"\"\"\n    Add a barrier (visual separator, optimization boundary).\n\n    Args:\n        *qubits: Qubits to include in barrier. If empty, all qubits.\n    \"\"\"\n    if not qubits:\n        qubits = tuple(range(self.num_qubits))\n    return self._add_gate('barrier', list(qubits))\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.bind_parameters","title":"<code>bind_parameters(params)</code>","text":"<p>Bind parameter values to create a concrete circuit.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Union[Dict[Parameter, float], List[float]]</code> <p>Dict mapping Parameters to values, or list of values     (in order of self.parameters)</p> required <p>Returns:</p> Type Description <code>Circuit</code> <p>New circuit with bound parameters</p> Example <p>theta = Parameter('\u03b8') qc = Circuit(1).ry(theta, 0)</p> Source code in <code>metalq/circuit.py</code> <pre><code>def bind_parameters(self, \n                    params: Union[Dict[Parameter, float], List[float]]) -&gt; Circuit:\n    \"\"\"\n    Bind parameter values to create a concrete circuit.\n\n    Args:\n        params: Dict mapping Parameters to values, or list of values\n                (in order of self.parameters)\n\n    Returns:\n        New circuit with bound parameters\n\n    Example:\n        theta = Parameter('\u03b8')\n        qc = Circuit(1).ry(theta, 0)\n\n        # Dict binding\n        bound = qc.bind_parameters({theta: 0.5})\n\n        # List binding\n        bound = qc.bind_parameters([0.5])\n    \"\"\"\n    from .parameter import evaluate_parameter\n\n    # Convert list to dict\n    if isinstance(params, (list, tuple)):\n        param_list = self.parameters\n        if len(params) != len(param_list):\n            raise ValueError(\n                f\"Expected {len(param_list)} parameters, got {len(params)}\"\n            )\n        params = dict(zip(param_list, params))\n\n    # Create new circuit\n    new_circuit = Circuit(self.num_qubits, self.num_clbits)\n    new_circuit._measurements = self._measurements.copy()\n\n    # Bind each gate's parameters\n    for gate in self._gates:\n        new_params = []\n        for p in gate.params:\n            if is_parameterized(p):\n                new_params.append(evaluate_parameter(p, params))\n            else:\n                new_params.append(p)\n\n        new_circuit._gates.append(Gate(\n            name=gate.name,\n            qubits=gate.qubits.copy(),\n            params=new_params\n        ))\n\n    return new_circuit\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.bind_parameters--dict-binding","title":"Dict binding","text":"<p>bound = qc.bind_parameters({theta: 0.5})</p>"},{"location":"api/circuit/#metalq.Circuit.bind_parameters--list-binding","title":"List binding","text":"<p>bound = qc.bind_parameters([0.5])</p>"},{"location":"api/circuit/#metalq.Circuit.ccx","title":"<code>ccx(control1, control2, target)</code>","text":"<p>Toffoli (CCX) gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def ccx(self, control1: int, control2: int, target: int) -&gt; Circuit:\n    \"\"\"Toffoli (CCX) gate.\"\"\"\n    return self._add_gate('ccx', [control1, control2, target])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.ccz","title":"<code>ccz(qubit1, qubit2, qubit3)</code>","text":"<p>CCZ gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def ccz(self, qubit1: int, qubit2: int, qubit3: int) -&gt; Circuit:\n    \"\"\"CCZ gate.\"\"\"\n    return self._add_gate('ccz', [qubit1, qubit2, qubit3])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.ch","title":"<code>ch(control, target)</code>","text":"<p>Controlled-Hadamard gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def ch(self, control: int, target: int) -&gt; Circuit:\n    \"\"\"Controlled-Hadamard gate.\"\"\"\n    return self._add_gate('ch', [control, target])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.cnot","title":"<code>cnot(control, target)</code>","text":"<p>Alias for cx.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def cnot(self, control: int, target: int) -&gt; Circuit:\n    \"\"\"Alias for cx.\"\"\"\n    return self.cx(control, target)\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.compose","title":"<code>compose(other, inplace=False)</code>","text":"<p>Compose with another circuit (append other's gates).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Circuit</code> <p>Circuit to append</p> required <code>inplace</code> <code>bool</code> <p>If True, modify this circuit</p> <code>False</code> <p>Returns:</p> Type Description <code>Circuit</code> <p>Composed circuit</p> Source code in <code>metalq/circuit.py</code> <pre><code>def compose(self, other: Circuit, inplace: bool = False) -&gt; Circuit:\n    \"\"\"\n    Compose with another circuit (append other's gates).\n\n    Args:\n        other: Circuit to append\n        inplace: If True, modify this circuit\n\n    Returns:\n        Composed circuit\n    \"\"\"\n    if other.num_qubits != self.num_qubits:\n        raise ValueError(\n            f\"Cannot compose circuits with different qubit counts: \"\n            f\"{self.num_qubits} vs {other.num_qubits}\"\n        )\n\n    if inplace:\n        result = self\n    else:\n        result = self.copy()\n\n    result._gates.extend(g for g in other._gates)\n    result._measurements.extend(other._measurements)\n    result._parameters.update(other._parameters)\n\n    return result\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.copy","title":"<code>copy()</code>","text":"<p>Create a deep copy of this circuit.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def copy(self) -&gt; Circuit:\n    \"\"\"Create a deep copy of this circuit.\"\"\"\n    new_circuit = Circuit(self.num_qubits, self.num_clbits)\n    new_circuit._gates = [\n        Gate(g.name, g.qubits.copy(), g.params.copy()) \n        for g in self._gates\n    ]\n    new_circuit._measurements = self._measurements.copy()\n    new_circuit._parameters = self._parameters.copy()\n    return new_circuit\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.cp","title":"<code>cp(theta, control, target)</code>","text":"<p>Controlled-Phase gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def cp(self, theta: Union[float, Parameter], control: int, target: int) -&gt; Circuit:\n    \"\"\"Controlled-Phase gate.\"\"\"\n    return self._add_gate('cp', [control, target], [theta])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.crx","title":"<code>crx(theta, control, target)</code>","text":"<p>Controlled-RX gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def crx(self, theta: Union[float, Parameter], control: int, target: int) -&gt; Circuit:\n    \"\"\"Controlled-RX gate.\"\"\"\n    return self._add_gate('crx', [control, target], [theta])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.cry","title":"<code>cry(theta, control, target)</code>","text":"<p>Controlled-RY gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def cry(self, theta: Union[float, Parameter], control: int, target: int) -&gt; Circuit:\n    \"\"\"Controlled-RY gate.\"\"\"\n    return self._add_gate('cry', [control, target], [theta])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.crz","title":"<code>crz(theta, control, target)</code>","text":"<p>Controlled-RZ gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def crz(self, theta: Union[float, Parameter], control: int, target: int) -&gt; Circuit:\n    \"\"\"Controlled-RZ gate.\"\"\"\n    return self._add_gate('crz', [control, target], [theta])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.cs","title":"<code>cs(control, target)</code>","text":"<p>Controlled-S gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def cs(self, control: int, target: int) -&gt; Circuit:\n    \"\"\"Controlled-S gate.\"\"\"\n    return self._add_gate('cs', [control, target])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.csdg","title":"<code>csdg(control, target)</code>","text":"<p>Controlled-S-dagger gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def csdg(self, control: int, target: int) -&gt; Circuit:\n    \"\"\"Controlled-S-dagger gate.\"\"\"\n    return self._add_gate('csdg', [control, target])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.cswap","title":"<code>cswap(control, target1, target2)</code>","text":"<p>Fredkin (CSWAP) gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def cswap(self, control: int, target1: int, target2: int) -&gt; Circuit:\n    \"\"\"Fredkin (CSWAP) gate.\"\"\"\n    return self._add_gate('cswap', [control, target1, target2])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.csx","title":"<code>csx(control, target)</code>","text":"<p>Controlled-Sqrt(X) gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def csx(self, control: int, target: int) -&gt; Circuit:\n    \"\"\"Controlled-Sqrt(X) gate.\"\"\"\n    return self._add_gate('csx', [control, target])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.cu","title":"<code>cu(theta, phi, lam, gamma, control, target)</code>","text":"<p>Controlled-U gate with global phase.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def cu(self, theta: Union[float, Parameter], \n       phi: Union[float, Parameter], \n       lam: Union[float, Parameter], \n       gamma: Union[float, Parameter],\n       control: int, target: int) -&gt; Circuit:\n    \"\"\"Controlled-U gate with global phase.\"\"\"\n    return self._add_gate('cu', [control, target], [theta, phi, lam, gamma])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.cu1","title":"<code>cu1(lam, control, target)</code>","text":"<p>Controlled-U1 gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def cu1(self, lam: Union[float, Parameter], control: int, target: int) -&gt; Circuit:\n    \"\"\"Controlled-U1 gate.\"\"\"\n    return self._add_gate('cu1', [control, target], [lam])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.cu3","title":"<code>cu3(theta, phi, lam, control, target)</code>","text":"<p>Controlled-U3 gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def cu3(self, theta: Union[float, Parameter], \n        phi: Union[float, Parameter], \n        lam: Union[float, Parameter],\n        control: int, target: int) -&gt; Circuit:\n    \"\"\"Controlled-U3 gate.\"\"\"\n    return self._add_gate('cu3', [control, target], [theta, phi, lam])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.cx","title":"<code>cx(control, target)</code>","text":"<p>CNOT (Controlled-X) gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def cx(self, control: int, target: int) -&gt; Circuit:\n    \"\"\"CNOT (Controlled-X) gate.\"\"\"\n    return self._add_gate('cx', [control, target])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.cy","title":"<code>cy(control, target)</code>","text":"<p>Controlled-Y gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def cy(self, control: int, target: int) -&gt; Circuit:\n    \"\"\"Controlled-Y gate.\"\"\"\n    return self._add_gate('cy', [control, target])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.cz","title":"<code>cz(control, target)</code>","text":"<p>Controlled-Z gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def cz(self, control: int, target: int) -&gt; Circuit:\n    \"\"\"Controlled-Z gate.\"\"\"\n    return self._add_gate('cz', [control, target])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.dcx","title":"<code>dcx(qubit1, qubit2)</code>","text":"<p>Double CNOT gate (DCX).</p> Source code in <code>metalq/circuit.py</code> <pre><code>def dcx(self, qubit1: int, qubit2: int) -&gt; Circuit:\n    \"\"\"Double CNOT gate (DCX).\"\"\"\n    return self._add_gate('dcx', [qubit1, qubit2])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.draw","title":"<code>draw(output='text')</code>","text":"<p>Draw the circuit.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>'text' for ASCII art, 'latex' for LaTeX source</p> <code>'text'</code> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the circuit</p> Source code in <code>metalq/circuit.py</code> <pre><code>def draw(self, output: str = 'text') -&gt; str:\n    \"\"\"\n    Draw the circuit.\n\n    Args:\n        output: 'text' for ASCII art, 'latex' for LaTeX source\n\n    Returns:\n        String representation of the circuit\n    \"\"\"\n    from .visualization import draw_circuit\n    return draw_circuit(self, output=output)\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.ecr","title":"<code>ecr(qubit1, qubit2)</code>","text":"<p>Echoed Cross-Resonance gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def ecr(self, qubit1: int, qubit2: int) -&gt; Circuit:\n    \"\"\"Echoed Cross-Resonance gate.\"\"\"\n    return self._add_gate('ecr', [qubit1, qubit2])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.fredkin","title":"<code>fredkin(control, target1, target2)</code>","text":"<p>Alias for cswap.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def fredkin(self, control: int, target1: int, target2: int) -&gt; Circuit:\n    \"\"\"Alias for cswap.\"\"\"\n    return self.cswap(control, target1, target2)\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create circuit from dictionary.</p> Source code in <code>metalq/circuit.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; Circuit:\n    \"\"\"Create circuit from dictionary.\"\"\"\n    circuit = cls(data['num_qubits'], data.get('num_clbits'))\n\n    for g in data['gates']:\n        circuit._gates.append(Gate(\n            name=g['name'],\n            qubits=g['qubits'],\n            params=g.get('params', [])\n        ))\n\n    circuit._measurements = [tuple(m) for m in data.get('measurements', [])]\n    return circuit\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.h","title":"<code>h(qubit)</code>","text":"<p>Hadamard gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def h(self, qubit: int) -&gt; Circuit:\n    \"\"\"Hadamard gate.\"\"\"\n    return self._add_gate('h', [qubit])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.has_measurements","title":"<code>has_measurements()</code>","text":"<p>Check if circuit has any measurements.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def has_measurements(self) -&gt; bool:\n    \"\"\"Check if circuit has any measurements.\"\"\"\n    return len(self._measurements) &gt; 0\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.id","title":"<code>id(qubit)</code>","text":"<p>Identity gate (no-op, useful for timing).</p> Source code in <code>metalq/circuit.py</code> <pre><code>def id(self, qubit: int) -&gt; Circuit:\n    \"\"\"Identity gate (no-op, useful for timing).\"\"\"\n    return self._add_gate('id', [qubit])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.inverse","title":"<code>inverse()</code>","text":"<p>Return the inverse (adjoint) of this circuit.</p> <p>Returns:</p> Type Description <code>Circuit</code> <p>New circuit with gates in reverse order and inverted</p> Source code in <code>metalq/circuit.py</code> <pre><code>def inverse(self) -&gt; Circuit:\n    \"\"\"\n    Return the inverse (adjoint) of this circuit.\n\n    Returns:\n        New circuit with gates in reverse order and inverted\n    \"\"\"\n    new_circuit = Circuit(self.num_qubits, self.num_clbits)\n\n    for gate in reversed(self._gates):\n        inv_gate = self._invert_gate(gate)\n        new_circuit._gates.append(inv_gate)\n\n    new_circuit._parameters = self._parameters.copy()\n    return new_circuit\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.iswap","title":"<code>iswap(qubit1, qubit2)</code>","text":"<p>iSWAP gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def iswap(self, qubit1: int, qubit2: int) -&gt; Circuit:\n    \"\"\"iSWAP gate.\"\"\"\n    return self._add_gate('iswap', [qubit1, qubit2])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.measure","title":"<code>measure(qubit, clbit)</code>","text":"<p>Measure a qubit into a classical bit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>int</code> <p>Qubit index to measure</p> required <code>clbit</code> <code>int</code> <p>Classical bit to store result</p> required Source code in <code>metalq/circuit.py</code> <pre><code>def measure(self, qubit: int, clbit: int) -&gt; Circuit:\n    \"\"\"\n    Measure a qubit into a classical bit.\n\n    Args:\n        qubit: Qubit index to measure\n        clbit: Classical bit to store result\n    \"\"\"\n    self._validate_qubit(qubit)\n    if not 0 &lt;= clbit &lt; self.num_clbits:\n        raise ValueError(f\"clbit {clbit} out of range [0, {self.num_clbits})\")\n\n    self._measurements.append((qubit, clbit))\n    return self\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.measure_all","title":"<code>measure_all()</code>","text":"<p>Measure all qubits into corresponding classical bits.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def measure_all(self) -&gt; Circuit:\n    \"\"\"Measure all qubits into corresponding classical bits.\"\"\"\n    for i in range(min(self.num_qubits, self.num_clbits)):\n        self._measurements.append((i, i))\n    return self\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.p","title":"<code>p(theta, qubit)</code>","text":"<p>Phase gate (rotation around Z with global phase).</p> Source code in <code>metalq/circuit.py</code> <pre><code>def p(self, theta: Union[float, Parameter], qubit: int) -&gt; Circuit:\n    \"\"\"Phase gate (rotation around Z with global phase).\"\"\"\n    return self._add_gate('p', [qubit], [theta])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.r","title":"<code>r(theta, phi, qubit)</code>","text":"<p>Rotation gate R(\u03b8, \u03c6) = exp(-i \u03b8/2 (cos(\u03c6)X + sin(\u03c6)Y)).</p> Source code in <code>metalq/circuit.py</code> <pre><code>def r(self, theta: Union[float, Parameter], \n      phi: Union[float, Parameter], qubit: int) -&gt; Circuit:\n    \"\"\"Rotation gate R(\u03b8, \u03c6) = exp(-i \u03b8/2 (cos(\u03c6)X + sin(\u03c6)Y)).\"\"\"\n    return self._add_gate('r', [qubit], [theta, phi])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.rx","title":"<code>rx(theta, qubit)</code>","text":"<p>Rotation around X-axis by angle theta.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def rx(self, theta: Union[float, Parameter], qubit: int) -&gt; Circuit:\n    \"\"\"Rotation around X-axis by angle theta.\"\"\"\n    return self._add_gate('rx', [qubit], [theta])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.rxx","title":"<code>rxx(theta, qubit1, qubit2)</code>","text":"<p>RXX (Ising XX coupling) gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def rxx(self, theta: Union[float, Parameter], qubit1: int, qubit2: int) -&gt; Circuit:\n    \"\"\"RXX (Ising XX coupling) gate.\"\"\"\n    return self._add_gate('rxx', [qubit1, qubit2], [theta])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.ry","title":"<code>ry(theta, qubit)</code>","text":"<p>Rotation around Y-axis by angle theta.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def ry(self, theta: Union[float, Parameter], qubit: int) -&gt; Circuit:\n    \"\"\"Rotation around Y-axis by angle theta.\"\"\"\n    return self._add_gate('ry', [qubit], [theta])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.ryy","title":"<code>ryy(theta, qubit1, qubit2)</code>","text":"<p>RYY (Ising YY coupling) gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def ryy(self, theta: Union[float, Parameter], qubit1: int, qubit2: int) -&gt; Circuit:\n    \"\"\"RYY (Ising YY coupling) gate.\"\"\"\n    return self._add_gate('ryy', [qubit1, qubit2], [theta])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.rz","title":"<code>rz(theta, qubit)</code>","text":"<p>Rotation around Z-axis by angle theta.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def rz(self, theta: Union[float, Parameter], qubit: int) -&gt; Circuit:\n    \"\"\"Rotation around Z-axis by angle theta.\"\"\"\n    return self._add_gate('rz', [qubit], [theta])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.rzx","title":"<code>rzx(theta, qubit1, qubit2)</code>","text":"<p>RZX gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def rzx(self, theta: Union[float, Parameter], qubit1: int, qubit2: int) -&gt; Circuit:\n    \"\"\"RZX gate.\"\"\"\n    return self._add_gate('rzx', [qubit1, qubit2], [theta])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.rzz","title":"<code>rzz(theta, qubit1, qubit2)</code>","text":"<p>RZZ (Ising ZZ coupling) gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def rzz(self, theta: Union[float, Parameter], qubit1: int, qubit2: int) -&gt; Circuit:\n    \"\"\"RZZ (Ising ZZ coupling) gate.\"\"\"\n    return self._add_gate('rzz', [qubit1, qubit2], [theta])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.s","title":"<code>s(qubit)</code>","text":"<p>S gate (sqrt(Z), phase gate with \u03b8=\u03c0/2).</p> Source code in <code>metalq/circuit.py</code> <pre><code>def s(self, qubit: int) -&gt; Circuit:\n    \"\"\"S gate (sqrt(Z), phase gate with \u03b8=\u03c0/2).\"\"\"\n    return self._add_gate('s', [qubit])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.sdg","title":"<code>sdg(qubit)</code>","text":"<p>S-dagger gate (inverse of S).</p> Source code in <code>metalq/circuit.py</code> <pre><code>def sdg(self, qubit: int) -&gt; Circuit:\n    \"\"\"S-dagger gate (inverse of S).\"\"\"\n    return self._add_gate('sdg', [qubit])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.swap","title":"<code>swap(qubit1, qubit2)</code>","text":"<p>SWAP gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def swap(self, qubit1: int, qubit2: int) -&gt; Circuit:\n    \"\"\"SWAP gate.\"\"\"\n    return self._add_gate('swap', [qubit1, qubit2])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.sx","title":"<code>sx(qubit)</code>","text":"<p>Sqrt(X) gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def sx(self, qubit: int) -&gt; Circuit:\n    \"\"\"Sqrt(X) gate.\"\"\"\n    return self._add_gate('sx', [qubit])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.sxdg","title":"<code>sxdg(qubit)</code>","text":"<p>Sqrt(X)-dagger gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def sxdg(self, qubit: int) -&gt; Circuit:\n    \"\"\"Sqrt(X)-dagger gate.\"\"\"\n    return self._add_gate('sxdg', [qubit])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.t","title":"<code>t(qubit)</code>","text":"<p>T gate (sqrt(S), phase gate with \u03b8=\u03c0/4).</p> Source code in <code>metalq/circuit.py</code> <pre><code>def t(self, qubit: int) -&gt; Circuit:\n    \"\"\"T gate (sqrt(S), phase gate with \u03b8=\u03c0/4).\"\"\"\n    return self._add_gate('t', [qubit])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.tdg","title":"<code>tdg(qubit)</code>","text":"<p>T-dagger gate (inverse of T).</p> Source code in <code>metalq/circuit.py</code> <pre><code>def tdg(self, qubit: int) -&gt; Circuit:\n    \"\"\"T-dagger gate (inverse of T).\"\"\"\n    return self._add_gate('tdg', [qubit])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert circuit to dictionary for serialization.</p> <p>Used for passing to native backend.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert circuit to dictionary for serialization.\n\n    Used for passing to native backend.\n    \"\"\"\n    return {\n        'num_qubits': self.num_qubits,\n        'num_clbits': self.num_clbits,\n        'gates': [g.to_dict() for g in self._gates],\n        'measurements': self._measurements,\n    }\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.toffoli","title":"<code>toffoli(control1, control2, target)</code>","text":"<p>Alias for ccx.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def toffoli(self, control1: int, control2: int, target: int) -&gt; Circuit:\n    \"\"\"Alias for ccx.\"\"\"\n    return self.ccx(control1, control2, target)\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.u","title":"<code>u(theta, phi, lam, qubit)</code>","text":"<p>Universal single-qubit gate U(\u03b8, \u03c6, \u03bb).</p> <p>U(\u03b8, \u03c6, \u03bb) = [[cos(\u03b8/2), -e^(i\u03bb)sin(\u03b8/2)],               [e^(i\u03c6)sin(\u03b8/2), e^(i(\u03c6+\u03bb))cos(\u03b8/2)]]</p> Source code in <code>metalq/circuit.py</code> <pre><code>def u(self, theta: Union[float, Parameter], \n      phi: Union[float, Parameter], \n      lam: Union[float, Parameter], \n      qubit: int) -&gt; Circuit:\n    \"\"\"\n    Universal single-qubit gate U(\u03b8, \u03c6, \u03bb).\n\n    U(\u03b8, \u03c6, \u03bb) = [[cos(\u03b8/2), -e^(i\u03bb)sin(\u03b8/2)],\n                  [e^(i\u03c6)sin(\u03b8/2), e^(i(\u03c6+\u03bb))cos(\u03b8/2)]]\n    \"\"\"\n    return self._add_gate('u', [qubit], [theta, phi, lam])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.u1","title":"<code>u1(lam, qubit)</code>","text":"<p>U1 gate (equivalent to p gate).</p> Source code in <code>metalq/circuit.py</code> <pre><code>def u1(self, lam: Union[float, Parameter], qubit: int) -&gt; Circuit:\n    \"\"\"U1 gate (equivalent to p gate).\"\"\"\n    return self._add_gate('u1', [qubit], [lam])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.u2","title":"<code>u2(phi, lam, qubit)</code>","text":"<p>U2 gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def u2(self, phi: Union[float, Parameter], \n       lam: Union[float, Parameter], qubit: int) -&gt; Circuit:\n    \"\"\"U2 gate.\"\"\"\n    return self._add_gate('u2', [qubit], [phi, lam])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.u3","title":"<code>u3(theta, phi, lam, qubit)</code>","text":"<p>U3 gate (same as u).</p> Source code in <code>metalq/circuit.py</code> <pre><code>def u3(self, theta: Union[float, Parameter], \n       phi: Union[float, Parameter], \n       lam: Union[float, Parameter], \n       qubit: int) -&gt; Circuit:\n    \"\"\"U3 gate (same as u).\"\"\"\n    return self._add_gate('u3', [qubit], [theta, phi, lam])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.x","title":"<code>x(qubit)</code>","text":"<p>Pauli-X (NOT) gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def x(self, qubit: int) -&gt; Circuit:\n    \"\"\"Pauli-X (NOT) gate.\"\"\"\n    return self._add_gate('x', [qubit])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.y","title":"<code>y(qubit)</code>","text":"<p>Pauli-Y gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def y(self, qubit: int) -&gt; Circuit:\n    \"\"\"Pauli-Y gate.\"\"\"\n    return self._add_gate('y', [qubit])\n</code></pre>"},{"location":"api/circuit/#metalq.Circuit.z","title":"<code>z(qubit)</code>","text":"<p>Pauli-Z gate.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def z(self, qubit: int) -&gt; Circuit:\n    \"\"\"Pauli-Z gate.\"\"\"\n    return self._add_gate('z', [qubit])\n</code></pre>"},{"location":"api/circuit/#gates","title":"Gates","text":"<p>Internal representation of a quantum gate.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Gate name (lowercase)</p> <code>qubits</code> <code>List[int]</code> <p>List of qubit indices</p> <code>params</code> <code>List[Union[float, Parameter, ParameterExpression]]</code> <p>List of parameters (float or Parameter)</p> Source code in <code>metalq/circuit.py</code> <pre><code>@dataclass\nclass Gate:\n    \"\"\"\n    Internal representation of a quantum gate.\n\n    Attributes:\n        name: Gate name (lowercase)\n        qubits: List of qubit indices\n        params: List of parameters (float or Parameter)\n    \"\"\"\n    name: str\n    qubits: List[int]\n    params: List[Union[float, Parameter, ParameterExpression]] = field(default_factory=list)\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n        return {\n            'name': self.name,\n            'qubits': self.qubits,\n            'params': [\n                p if isinstance(p, (int, float)) else str(p) \n                for p in self.params\n            ]\n        }\n</code></pre>"},{"location":"api/circuit/#metalq.circuit.Gate.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary for JSON serialization.</p> Source code in <code>metalq/circuit.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n    return {\n        'name': self.name,\n        'qubits': self.qubits,\n        'params': [\n            p if isinstance(p, (int, float)) else str(p) \n            for p in self.params\n        ]\n    }\n</code></pre>"},{"location":"api/circuit/#parameters","title":"Parameters","text":"<p>Symbolic parameter for parameterized quantum circuits.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Human-readable name</p> Example <p>theta = Parameter('\u03b8') phi = Parameter('\u03c6')</p> <p>qc = Circuit(2) qc.ry(theta, 0) qc.rz(phi, 1)</p> Source code in <code>metalq/parameter.py</code> <pre><code>class Parameter:\n    \"\"\"\n    Symbolic parameter for parameterized quantum circuits.\n\n    Attributes:\n        name: Human-readable name\n\n    Example:\n        theta = Parameter('\u03b8')\n        phi = Parameter('\u03c6')\n\n        qc = Circuit(2)\n        qc.ry(theta, 0)\n        qc.rz(phi, 1)\n    \"\"\"\n\n    __slots__ = ('_name', '_uuid')\n\n    def __init__(self, name: Optional[str] = None):\n        \"\"\"\n        Initialize a parameter.\n\n        Args:\n            name: Human-readable name. If None, auto-generated.\n        \"\"\"\n        self._name = name if name is not None else f\"p_{uuid.uuid4().hex[:8]}\"\n        self._uuid = uuid.uuid4()\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Get parameter name.\"\"\"\n        return self._name\n\n    def __repr__(self) -&gt; str:\n        return f\"Parameter('{self._name}')\"\n\n    def __str__(self) -&gt; str:\n        return self._name\n\n    def __hash__(self) -&gt; int:\n        return hash(self._uuid)\n\n    def __eq__(self, other: object) -&gt; bool:\n        if isinstance(other, Parameter):\n            return self._uuid == other._uuid\n        return False\n\n    def __ne__(self, other: object) -&gt; bool:\n        return not self.__eq__(other)\n\n    # ==================== \u7b97\u8853\u6f14\u7b97\u30b5\u30dd\u30fc\u30c8 ====================\n    # \u30d1\u30e9\u30e1\u30fc\u30bf\u5f0f\u3092\u30b5\u30dd\u30fc\u30c8\uff08\u5c06\u6765\u306e\u62e1\u5f35\u7528\uff09\n\n    def __add__(self, other: Union[Parameter, float]) -&gt; 'ParameterExpression':\n        return ParameterExpression(self, other, '+')\n\n    def __radd__(self, other: Union[Parameter, float]) -&gt; 'ParameterExpression':\n        return ParameterExpression(other, self, '+')\n\n    def __sub__(self, other: Union[Parameter, float]) -&gt; 'ParameterExpression':\n        return ParameterExpression(self, other, '-')\n\n    def __rsub__(self, other: Union[Parameter, float]) -&gt; 'ParameterExpression':\n        return ParameterExpression(other, self, '-')\n\n    def __mul__(self, other: Union[Parameter, float]) -&gt; 'ParameterExpression':\n        return ParameterExpression(self, other, '*')\n\n    def __rmul__(self, other: Union[Parameter, float]) -&gt; 'ParameterExpression':\n        return ParameterExpression(other, self, '*')\n\n    def __truediv__(self, other: Union[Parameter, float]) -&gt; 'ParameterExpression':\n        return ParameterExpression(self, other, '/')\n\n    def __neg__(self) -&gt; 'ParameterExpression':\n        return ParameterExpression(-1, self, '*')\n</code></pre> <p>Expression involving parameters (e.g., theta + 0.5, 2 * phi).</p> <p>\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u542b\u3080\u5f0f\u3002\u8a55\u4fa1\u6642\u306b\u5177\u4f53\u7684\u306a\u5024\u306b\u5909\u63db\u3055\u308c\u308b\u3002</p> Source code in <code>metalq/parameter.py</code> <pre><code>class ParameterExpression:\n    \"\"\"\n    Expression involving parameters (e.g., theta + 0.5, 2 * phi).\n\n    \u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u542b\u3080\u5f0f\u3002\u8a55\u4fa1\u6642\u306b\u5177\u4f53\u7684\u306a\u5024\u306b\u5909\u63db\u3055\u308c\u308b\u3002\n    \"\"\"\n\n    __slots__ = ('_left', '_right', '_op', '_parameters')\n\n    def __init__(self, left, right, op: str):\n        self._left = left\n        self._right = right\n        self._op = op\n\n        # \u542b\u307e\u308c\u308b\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u53ce\u96c6\n        self._parameters = set()\n        self._collect_parameters(left)\n        self._collect_parameters(right)\n\n    def _collect_parameters(self, obj):\n        \"\"\"\u518d\u5e30\u7684\u306b\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u53ce\u96c6\"\"\"\n        if isinstance(obj, Parameter):\n            self._parameters.add(obj)\n        elif isinstance(obj, ParameterExpression):\n            self._parameters.update(obj._parameters)\n\n    @property\n    def parameters(self) -&gt; Set[Parameter]:\n        \"\"\"Get all parameters in this expression.\"\"\"\n        return self._parameters.copy()\n\n    def evaluate(self, param_values: dict) -&gt; float:\n        \"\"\"\n        Evaluate expression with concrete parameter values.\n\n        Args:\n            param_values: Dict mapping Parameter to float\n\n        Returns:\n            Evaluated float value\n        \"\"\"\n        left_val = self._eval_operand(self._left, param_values)\n        right_val = self._eval_operand(self._right, param_values)\n\n        if self._op == '+':\n            return left_val + right_val\n        elif self._op == '-':\n            return left_val - right_val\n        elif self._op == '*':\n            return left_val * right_val\n        elif self._op == '/':\n            return left_val / right_val\n        else:\n            raise ValueError(f\"Unknown operator: {self._op}\")\n\n    def _eval_operand(self, operand, param_values: dict) -&gt; float:\n        \"\"\"Evaluate a single operand.\"\"\"\n        if isinstance(operand, Parameter):\n            if operand not in param_values:\n                raise ValueError(f\"Parameter {operand.name} not bound\")\n            return param_values[operand]\n        elif isinstance(operand, ParameterExpression):\n            return operand.evaluate(param_values)\n        else:\n            return float(operand)\n\n    def grad(self, param: Parameter) -&gt; float:\n        \"\"\"\n        Calculate partial derivative with respect to a parameter.\n        Returns float (assuming linear coefficients for now).\n        Examples:\n            (2*theta).grad(theta) -&gt; 2.0\n            (theta + phi).grad(theta) -&gt; 1.0\n        \"\"\"\n        if param not in self._parameters:\n            return 0.0\n\n        # Derivative rules\n        # d(u+v)/dx = du/dx + dv/dx\n        # d(u*v)/dx = du/dx * v + u * dv/dx (Product rule) - Note: v must be const if linear?\n        # For QAOA V1, expressions are linear combination: c * p.\n        # We assume linearity for MVP simplicity, or simple product.\n\n        l_grad = self._grad_operand(self._left, param)\n        r_grad = self._grad_operand(self._right, param)\n\n        # We need values of operands for product rule?\n        # If expression is linear `2*theta`, left=2 (grad=0), right=theta (grad=1).\n        # d(2*theta) = 0*theta + 2*1 = 2.\n        # So we need CURRENT VALUES if non-linear?\n        # But `grad` here returns float.\n        # For linear expressions (QAOA), value independent.\n        # For non-linear `theta*phi`, derivative depends on value.\n        # MetalQ V1 QAOA uses `2*gamma`. Const * Param.\n        # So we can evaluate `operand` if it is constant.\n\n        # Helper to get value if constant, else raise?\n        # We'll try to evaluate operands assuming they are constant relative to `param`?\n        # No, simpler: \n        # d(L + R) = dL + dR\n        # d(L * R) = dL*R + L*dR.\n\n        # For now, let's support only Constant * Parameter or Parameter + Parameter.\n\n        val_l = self._get_const_value(self._left)\n        val_r = self._get_const_value(self._right)\n\n        if self._op == '+':\n            return l_grad + r_grad\n        elif self._op == '-':\n            return l_grad - r_grad\n        elif self._op == '*':\n            # Product rule\n            # If L is const, dL=0. term is L*dR.\n            # If R is const, dR=0. term is dL*R.\n            # If both variable? We need values.\n            # Return error for non-linear?\n            term1 = l_grad * val_r if val_r is not None else 0.0 # Approximation if non-const\n            term2 = val_l * r_grad if val_l is not None else 0.0\n\n            if val_l is None and val_r is None:\n                raise NotImplementedError(\"Non-linear gradient (param*param) not supported without context.\")\n\n            return term1 + term2\n        elif self._op == '/':\n            # Quotient rule d(u/v) = (du*v - u*dv)/v^2\n            if val_r is None:\n                raise NotImplementedError(\"Division by parameter not supported\")\n            return (l_grad * val_r - (val_l if val_l else 0) * r_grad) / (val_r * val_r)\n\n        return 0.0\n\n    def _grad_operand(self, operand, param):\n        if isinstance(operand, Parameter):\n            return 1.0 if operand == param else 0.0\n        elif isinstance(operand, ParameterExpression):\n            return operand.grad(param)\n        else:\n            return 0.0 # Constant\n\n    def _get_const_value(self, operand) -&gt; Optional[float]:\n        \"\"\"Return value if operand is constant, else None.\"\"\"\n        if isinstance(operand, (int, float)):\n            return float(operand)\n        if isinstance(operand, Parameter):\n            return None\n        if isinstance(operand, ParameterExpression):\n            # Try to resolve if sub-expression is constant\n            try:\n                if len(operand.parameters) == 0:\n                     return operand.evaluate({})\n            except:\n                pass\n            return None\n        return None\n\n\n    def __repr__(self) -&gt; str:\n        return f\"({self._left} {self._op} {self._right})\"\n\n    def __str__(self) -&gt; str:\n        return self.__repr__()\n\n    # \u5f0f\u306e\u9023\u9396\u3092\u30b5\u30dd\u30fc\u30c8\n    def __add__(self, other) -&gt; 'ParameterExpression':\n        return ParameterExpression(self, other, '+')\n\n    def __radd__(self, other) -&gt; 'ParameterExpression':\n        return ParameterExpression(other, self, '+')\n\n    def __sub__(self, other) -&gt; 'ParameterExpression':\n        return ParameterExpression(self, other, '-')\n\n    def __mul__(self, other) -&gt; 'ParameterExpression':\n        return ParameterExpression(self, other, '*')\n\n    def __rmul__(self, other) -&gt; 'ParameterExpression':\n        return ParameterExpression(other, self, '*')\n\n    def __truediv__(self, other) -&gt; 'ParameterExpression':\n        return ParameterExpression(self, other, '/')\n\n    def __neg__(self) -&gt; 'ParameterExpression':\n        return ParameterExpression(-1, self, '*')\n</code></pre>"},{"location":"api/circuit/#metalq.Parameter.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get parameter name.</p>"},{"location":"api/circuit/#metalq.Parameter.__init__","title":"<code>__init__(name=None)</code>","text":"<p>Initialize a parameter.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Human-readable name. If None, auto-generated.</p> <code>None</code> Source code in <code>metalq/parameter.py</code> <pre><code>def __init__(self, name: Optional[str] = None):\n    \"\"\"\n    Initialize a parameter.\n\n    Args:\n        name: Human-readable name. If None, auto-generated.\n    \"\"\"\n    self._name = name if name is not None else f\"p_{uuid.uuid4().hex[:8]}\"\n    self._uuid = uuid.uuid4()\n</code></pre>"},{"location":"api/circuit/#metalq.ParameterExpression.parameters","title":"<code>parameters</code>  <code>property</code>","text":"<p>Get all parameters in this expression.</p>"},{"location":"api/circuit/#metalq.ParameterExpression.evaluate","title":"<code>evaluate(param_values)</code>","text":"<p>Evaluate expression with concrete parameter values.</p> <p>Parameters:</p> Name Type Description Default <code>param_values</code> <code>dict</code> <p>Dict mapping Parameter to float</p> required <p>Returns:</p> Type Description <code>float</code> <p>Evaluated float value</p> Source code in <code>metalq/parameter.py</code> <pre><code>def evaluate(self, param_values: dict) -&gt; float:\n    \"\"\"\n    Evaluate expression with concrete parameter values.\n\n    Args:\n        param_values: Dict mapping Parameter to float\n\n    Returns:\n        Evaluated float value\n    \"\"\"\n    left_val = self._eval_operand(self._left, param_values)\n    right_val = self._eval_operand(self._right, param_values)\n\n    if self._op == '+':\n        return left_val + right_val\n    elif self._op == '-':\n        return left_val - right_val\n    elif self._op == '*':\n        return left_val * right_val\n    elif self._op == '/':\n        return left_val / right_val\n    else:\n        raise ValueError(f\"Unknown operator: {self._op}\")\n</code></pre>"},{"location":"api/circuit/#metalq.ParameterExpression.grad","title":"<code>grad(param)</code>","text":"<p>Calculate partial derivative with respect to a parameter. Returns float (assuming linear coefficients for now). Examples:     (2*theta).grad(theta) -&gt; 2.0     (theta + phi).grad(theta) -&gt; 1.0</p> Source code in <code>metalq/parameter.py</code> <pre><code>def grad(self, param: Parameter) -&gt; float:\n    \"\"\"\n    Calculate partial derivative with respect to a parameter.\n    Returns float (assuming linear coefficients for now).\n    Examples:\n        (2*theta).grad(theta) -&gt; 2.0\n        (theta + phi).grad(theta) -&gt; 1.0\n    \"\"\"\n    if param not in self._parameters:\n        return 0.0\n\n    # Derivative rules\n    # d(u+v)/dx = du/dx + dv/dx\n    # d(u*v)/dx = du/dx * v + u * dv/dx (Product rule) - Note: v must be const if linear?\n    # For QAOA V1, expressions are linear combination: c * p.\n    # We assume linearity for MVP simplicity, or simple product.\n\n    l_grad = self._grad_operand(self._left, param)\n    r_grad = self._grad_operand(self._right, param)\n\n    # We need values of operands for product rule?\n    # If expression is linear `2*theta`, left=2 (grad=0), right=theta (grad=1).\n    # d(2*theta) = 0*theta + 2*1 = 2.\n    # So we need CURRENT VALUES if non-linear?\n    # But `grad` here returns float.\n    # For linear expressions (QAOA), value independent.\n    # For non-linear `theta*phi`, derivative depends on value.\n    # MetalQ V1 QAOA uses `2*gamma`. Const * Param.\n    # So we can evaluate `operand` if it is constant.\n\n    # Helper to get value if constant, else raise?\n    # We'll try to evaluate operands assuming they are constant relative to `param`?\n    # No, simpler: \n    # d(L + R) = dL + dR\n    # d(L * R) = dL*R + L*dR.\n\n    # For now, let's support only Constant * Parameter or Parameter + Parameter.\n\n    val_l = self._get_const_value(self._left)\n    val_r = self._get_const_value(self._right)\n\n    if self._op == '+':\n        return l_grad + r_grad\n    elif self._op == '-':\n        return l_grad - r_grad\n    elif self._op == '*':\n        # Product rule\n        # If L is const, dL=0. term is L*dR.\n        # If R is const, dR=0. term is dL*R.\n        # If both variable? We need values.\n        # Return error for non-linear?\n        term1 = l_grad * val_r if val_r is not None else 0.0 # Approximation if non-const\n        term2 = val_l * r_grad if val_l is not None else 0.0\n\n        if val_l is None and val_r is None:\n            raise NotImplementedError(\"Non-linear gradient (param*param) not supported without context.\")\n\n        return term1 + term2\n    elif self._op == '/':\n        # Quotient rule d(u/v) = (du*v - u*dv)/v^2\n        if val_r is None:\n            raise NotImplementedError(\"Division by parameter not supported\")\n        return (l_grad * val_r - (val_l if val_l else 0) * r_grad) / (val_r * val_r)\n\n    return 0.0\n</code></pre>"},{"location":"api/circuit/#operators","title":"Operators","text":"<p>Sum of Pauli terms: H = \u03a3\u1d62 c\u1d62 P\u1d62</p> Example <p>H = -1.0 * Z(0) @ Z(1) + 0.5 * X(0) + 0.5 * X(1)</p> Source code in <code>metalq/spin.py</code> <pre><code>class Hamiltonian:\n    \"\"\"\n    Sum of Pauli terms: H = \u03a3\u1d62 c\u1d62 P\u1d62\n\n    Example:\n        H = -1.0 * Z(0) @ Z(1) + 0.5 * X(0) + 0.5 * X(1)\n\n        # Get matrix form\n        matrix = H.to_matrix(num_qubits=2)\n\n        # Iterate over terms\n        for term in H.terms:\n            print(term)\n    \"\"\"\n\n    __slots__ = ('_terms',)\n\n    def __init__(self, terms: Optional[List[PauliTerm]] = None):\n        self._terms = terms or []\n\n    @property\n    def terms(self) -&gt; List[PauliTerm]:\n        \"\"\"Get list of terms (copy).\"\"\"\n        return self._terms.copy()\n\n    @property\n    def num_terms(self) -&gt; int:\n        \"\"\"Get number of terms.\"\"\"\n        return len(self._terms)\n\n    @property\n    def num_qubits(self) -&gt; int:\n        \"\"\"Infer minimum number of qubits needed.\"\"\"\n        if not self._terms:\n            return 0\n        return max(t.num_qubits for t in self._terms)\n\n    @property\n    def qubits(self) -&gt; Set[int]:\n        \"\"\"Get set of all qubits involved.\"\"\"\n        result = set()\n        for term in self._terms:\n            result.update(term.qubits)\n        return result\n\n    def __repr__(self) -&gt; str:\n        if not self._terms:\n            return \"0\"\n\n        parts = []\n        for i, term in enumerate(self._terms):\n            term_str = str(term)\n            if i == 0:\n                parts.append(term_str)\n            elif term_str.startswith('-'):\n                parts.append(f\" - {term_str[1:]}\")\n            else:\n                parts.append(f\" + {term_str}\")\n\n        return ''.join(parts)\n\n    def __iter__(self):\n        return iter(self._terms)\n\n    def __len__(self) -&gt; int:\n        return len(self._terms)\n\n    # ========================================================================\n    # Arithmetic Operations\n    # ========================================================================\n\n    def __neg__(self) -&gt; Hamiltonian:\n        return Hamiltonian([-t for t in self._terms])\n\n    def __add__(self, other: Union[int, float, complex, PauliTerm, Hamiltonian]) -&gt; Hamiltonian:\n        if isinstance(other, (int, float, complex)):\n            return Hamiltonian(self._terms + [PauliTerm(other, [])])\n        elif isinstance(other, PauliTerm):\n            return Hamiltonian(self._terms + [other])\n        elif isinstance(other, Hamiltonian):\n            return Hamiltonian(self._terms + other._terms)\n        return NotImplemented\n\n    def __radd__(self, other: Union[int, float, complex, PauliTerm]) -&gt; Hamiltonian:\n        return self.__add__(other)\n\n    def __sub__(self, other: Union[int, float, complex, PauliTerm, Hamiltonian]) -&gt; Hamiltonian:\n        if isinstance(other, (int, float, complex)):\n            return Hamiltonian(self._terms + [PauliTerm(-other, [])])\n        elif isinstance(other, PauliTerm):\n            return Hamiltonian(self._terms + [-other])\n        elif isinstance(other, Hamiltonian):\n            return Hamiltonian(self._terms + [-t for t in other._terms])\n        return NotImplemented\n\n    def __rsub__(self, other: Union[int, float, complex]) -&gt; Hamiltonian:\n        return Hamiltonian([PauliTerm(other, [])] + [-t for t in self._terms])\n\n    def __mul__(self, scalar: Union[int, float, complex]) -&gt; Hamiltonian:\n        if isinstance(scalar, (int, float, complex)):\n            return Hamiltonian([\n                PauliTerm(t.coeff * scalar, t.ops) \n                for t in self._terms\n            ])\n        return NotImplemented\n\n    def __rmul__(self, scalar: Union[int, float, complex]) -&gt; Hamiltonian:\n        return self.__mul__(scalar)\n\n    def __truediv__(self, scalar: Union[int, float, complex]) -&gt; Hamiltonian:\n        if isinstance(scalar, (int, float, complex)):\n            return Hamiltonian([\n                PauliTerm(t.coeff / scalar, t.ops) \n                for t in self._terms\n            ])\n        return NotImplemented\n\n    # ========================================================================\n    # Simplification\n    # ========================================================================\n\n    def simplify(self) -&gt; Hamiltonian:\n        \"\"\"\n        Combine like terms.\n\n        Returns:\n            New Hamiltonian with combined terms\n        \"\"\"\n        term_dict = {}\n\n        for term in self._terms:\n            # Create a hashable key from operators\n            key = tuple(sorted(term.ops))\n\n            if key in term_dict:\n                term_dict[key] = PauliTerm(\n                    term_dict[key].coeff + term.coeff,\n                    list(key)\n                )\n            else:\n                term_dict[key] = PauliTerm(term.coeff, list(key))\n\n        # Filter out zero terms\n        simplified = [t for t in term_dict.values() if abs(t.coeff) &gt; 1e-15]\n\n        return Hamiltonian(simplified)\n\n    # ========================================================================\n    # Matrix Conversion\n    # ========================================================================\n\n    def to_matrix(self, num_qubits: Optional[int] = None) -&gt; np.ndarray:\n        \"\"\"\n        Convert to full matrix representation.\n\n        Args:\n            num_qubits: Total number of qubits (inferred if not specified)\n\n        Returns:\n            2^n \u00d7 2^n complex Hermitian matrix\n        \"\"\"\n        if num_qubits is None:\n            num_qubits = self.num_qubits\n\n        if num_qubits == 0:\n            # Constant term only\n            const = sum(t.coeff for t in self._terms if not t.ops)\n            return np.array([[const]], dtype=np.complex128)\n\n        dim = 2 ** num_qubits\n        result = np.zeros((dim, dim), dtype=np.complex128)\n\n        for term in self._terms:\n            result += term.to_matrix(num_qubits)\n\n        return result\n\n    def to_sparse(self, num_qubits: Optional[int] = None):\n        \"\"\"\n        Convert to sparse matrix representation.\n\n        Returns:\n            scipy.sparse matrix\n        \"\"\"\n        from scipy import sparse\n        return sparse.csr_matrix(self.to_matrix(num_qubits))\n\n    # ========================================================================\n    # Serialization\n    # ========================================================================\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert to dictionary for serialization.\"\"\"\n        return {\n            'terms': [\n                {\n                    'coeff_real': t.coeff.real,\n                    'coeff_imag': t.coeff.imag,\n                    'ops': t.ops\n                }\n                for t in self._terms\n            ]\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; Hamiltonian:\n        \"\"\"Create from dictionary.\"\"\"\n        terms = [\n            PauliTerm(\n                complex(t['coeff_real'], t['coeff_imag']),\n                [tuple(op) for op in t['ops']]\n            )\n            for t in data['terms']\n        ]\n        return cls(terms)\n</code></pre> <p>A single Pauli term: coefficient * (P\u2080 \u2297 P\u2081 \u2297 ... \u2297 P\u2099)</p> <p>Attributes:</p> Name Type Description <code>coeff</code> <code>complex</code> <p>Complex coefficient</p> <code>ops</code> <code>List[Tuple[str, int]]</code> <p>List of (pauli_type, qubit_index) tuples</p> Example <p>term = PauliTerm(1.0, [('Z', 0), ('Z', 1)])  # Z\u2080 \u2297 Z\u2081</p> Source code in <code>metalq/spin.py</code> <pre><code>@dataclass\nclass PauliTerm:\n    \"\"\"\n    A single Pauli term: coefficient * (P\u2080 \u2297 P\u2081 \u2297 ... \u2297 P\u2099)\n\n    Attributes:\n        coeff: Complex coefficient\n        ops: List of (pauli_type, qubit_index) tuples\n\n    Example:\n        term = PauliTerm(1.0, [('Z', 0), ('Z', 1)])  # Z\u2080 \u2297 Z\u2081\n    \"\"\"\n    coeff: complex = 1.0\n    ops: List[Tuple[str, int]] = field(default_factory=list)\n\n    def __post_init__(self):\n        self.coeff = complex(self.coeff)\n\n    @property\n    def qubits(self) -&gt; Set[int]:\n        \"\"\"Get set of qubits this term acts on.\"\"\"\n        return {q for _, q in self.ops}\n\n    @property\n    def num_qubits(self) -&gt; int:\n        \"\"\"Infer minimum number of qubits needed.\"\"\"\n        if not self.ops:\n            return 0\n        return max(q for _, q in self.ops) + 1\n\n    def __repr__(self) -&gt; str:\n        if not self.ops:\n            return f\"{self.coeff}\"\n\n        ops_str = \" @ \".join(f\"{p}({q})\" for p, q in self.ops)\n\n        if self.coeff == 1:\n            return ops_str\n        elif self.coeff == -1:\n            return f\"-{ops_str}\"\n        elif self.coeff.imag == 0:\n            return f\"{self.coeff.real} * {ops_str}\"\n        else:\n            return f\"{self.coeff} * {ops_str}\"\n\n    def __hash__(self) -&gt; int:\n        return hash((self.coeff, tuple(self.ops)))\n\n    def __eq__(self, other: object) -&gt; bool:\n        if isinstance(other, PauliTerm):\n            return self.coeff == other.coeff and self.ops == other.ops\n        return False\n\n    # ========================================================================\n    # Arithmetic Operations\n    # ========================================================================\n\n    def __neg__(self) -&gt; PauliTerm:\n        return PauliTerm(-self.coeff, self.ops.copy())\n\n    def __mul__(self, other: Union[int, float, complex, PauliTerm]) -&gt; Union[PauliTerm, 'Hamiltonian']:\n        if isinstance(other, (int, float, complex)):\n            return PauliTerm(self.coeff * other, self.ops.copy())\n        elif isinstance(other, PauliTerm):\n            # Tensor product of two terms\n            return PauliTerm(\n                self.coeff * other.coeff,\n                self.ops + other.ops\n            )\n        return NotImplemented\n\n    def __rmul__(self, other: Union[int, float, complex]) -&gt; PauliTerm:\n        if isinstance(other, (int, float, complex)):\n            return PauliTerm(other * self.coeff, self.ops.copy())\n        return NotImplemented\n\n    def __matmul__(self, other: PauliTerm) -&gt; PauliTerm:\n        \"\"\"Tensor product using @ operator.\"\"\"\n        if isinstance(other, PauliTerm):\n            return PauliTerm(\n                self.coeff * other.coeff,\n                self.ops + other.ops\n            )\n        return NotImplemented\n\n    def __truediv__(self, other: Union[int, float, complex]) -&gt; PauliTerm:\n        if isinstance(other, (int, float, complex)):\n            return PauliTerm(self.coeff / other, self.ops.copy())\n        return NotImplemented\n\n    def __add__(self, other: Union[int, float, complex, PauliTerm, 'Hamiltonian']) -&gt; 'Hamiltonian':\n        if isinstance(other, (int, float, complex)):\n            return Hamiltonian([self, PauliTerm(other, [])])\n        elif isinstance(other, PauliTerm):\n            return Hamiltonian([self, other])\n        elif isinstance(other, Hamiltonian):\n            return Hamiltonian([self] + other.terms)\n        return NotImplemented\n\n    def __radd__(self, other: Union[int, float, complex, PauliTerm]) -&gt; 'Hamiltonian':\n        if isinstance(other, (int, float, complex)):\n            return Hamiltonian([PauliTerm(other, []), self])\n        return self.__add__(other)\n\n    def __sub__(self, other: Union[int, float, complex, PauliTerm, 'Hamiltonian']) -&gt; 'Hamiltonian':\n        if isinstance(other, (int, float, complex)):\n            return Hamiltonian([self, PauliTerm(-other, [])])\n        elif isinstance(other, PauliTerm):\n            return Hamiltonian([self, -other])\n        elif isinstance(other, Hamiltonian):\n            return Hamiltonian([self] + [-t for t in other.terms])\n        return NotImplemented\n\n    def __rsub__(self, other: Union[int, float, complex]) -&gt; 'Hamiltonian':\n        if isinstance(other, (int, float, complex)):\n            return Hamiltonian([PauliTerm(other, []), -self])\n        return NotImplemented\n\n    # ========================================================================\n    # Matrix Conversion\n    # ========================================================================\n\n    def to_matrix(self, num_qubits: Optional[int] = None) -&gt; np.ndarray:\n        \"\"\"\n        Convert to full matrix representation.\n\n        Args:\n            num_qubits: Total number of qubits (inferred if not specified)\n\n        Returns:\n            2^n \u00d7 2^n complex matrix\n        \"\"\"\n        if num_qubits is None:\n            num_qubits = self.num_qubits\n\n        if num_qubits == 0:\n            return np.array([[self.coeff]], dtype=np.complex128)\n\n        # Build operator dict\n        qubit_ops = {q: 'I' for q in range(num_qubits)}\n        for pauli, qubit in self.ops:\n            if qubit in qubit_ops:\n                # Multiply Paulis on same qubit\n                qubit_ops[qubit] = self._multiply_paulis(qubit_ops[qubit], pauli)\n            else:\n                qubit_ops[qubit] = pauli\n\n        # Tensor product\n        matrices = [_PAULI_MATRICES[qubit_ops[q]] for q in range(num_qubits)]\n\n        result = matrices[0]\n        for m in matrices[1:]:\n            result = np.kron(result, m)\n\n        return self.coeff * result\n\n    @staticmethod\n    def _multiply_paulis(p1: str, p2: str) -&gt; str:\n        \"\"\"Multiply two Pauli operators (simplified).\"\"\"\n        if p1 == 'I':\n            return p2\n        if p2 == 'I':\n            return p1\n        if p1 == p2:\n            return 'I'\n        # XY, YZ, ZX cases would need phase tracking\n        # For now, return the second one (simplified)\n        return p2\n</code></pre>"},{"location":"api/circuit/#metalq.Hamiltonian--get-matrix-form","title":"Get matrix form","text":"<p>matrix = H.to_matrix(num_qubits=2)</p>"},{"location":"api/circuit/#metalq.Hamiltonian--iterate-over-terms","title":"Iterate over terms","text":"<p>for term in H.terms:     print(term)</p>"},{"location":"api/circuit/#metalq.Hamiltonian.num_qubits","title":"<code>num_qubits</code>  <code>property</code>","text":"<p>Infer minimum number of qubits needed.</p>"},{"location":"api/circuit/#metalq.Hamiltonian.num_terms","title":"<code>num_terms</code>  <code>property</code>","text":"<p>Get number of terms.</p>"},{"location":"api/circuit/#metalq.Hamiltonian.qubits","title":"<code>qubits</code>  <code>property</code>","text":"<p>Get set of all qubits involved.</p>"},{"location":"api/circuit/#metalq.Hamiltonian.terms","title":"<code>terms</code>  <code>property</code>","text":"<p>Get list of terms (copy).</p>"},{"location":"api/circuit/#metalq.Hamiltonian.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create from dictionary.</p> Source code in <code>metalq/spin.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; Hamiltonian:\n    \"\"\"Create from dictionary.\"\"\"\n    terms = [\n        PauliTerm(\n            complex(t['coeff_real'], t['coeff_imag']),\n            [tuple(op) for op in t['ops']]\n        )\n        for t in data['terms']\n    ]\n    return cls(terms)\n</code></pre>"},{"location":"api/circuit/#metalq.Hamiltonian.simplify","title":"<code>simplify()</code>","text":"<p>Combine like terms.</p> <p>Returns:</p> Type Description <code>Hamiltonian</code> <p>New Hamiltonian with combined terms</p> Source code in <code>metalq/spin.py</code> <pre><code>def simplify(self) -&gt; Hamiltonian:\n    \"\"\"\n    Combine like terms.\n\n    Returns:\n        New Hamiltonian with combined terms\n    \"\"\"\n    term_dict = {}\n\n    for term in self._terms:\n        # Create a hashable key from operators\n        key = tuple(sorted(term.ops))\n\n        if key in term_dict:\n            term_dict[key] = PauliTerm(\n                term_dict[key].coeff + term.coeff,\n                list(key)\n            )\n        else:\n            term_dict[key] = PauliTerm(term.coeff, list(key))\n\n    # Filter out zero terms\n    simplified = [t for t in term_dict.values() if abs(t.coeff) &gt; 1e-15]\n\n    return Hamiltonian(simplified)\n</code></pre>"},{"location":"api/circuit/#metalq.Hamiltonian.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary for serialization.</p> Source code in <code>metalq/spin.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert to dictionary for serialization.\"\"\"\n    return {\n        'terms': [\n            {\n                'coeff_real': t.coeff.real,\n                'coeff_imag': t.coeff.imag,\n                'ops': t.ops\n            }\n            for t in self._terms\n        ]\n    }\n</code></pre>"},{"location":"api/circuit/#metalq.Hamiltonian.to_matrix","title":"<code>to_matrix(num_qubits=None)</code>","text":"<p>Convert to full matrix representation.</p> <p>Parameters:</p> Name Type Description Default <code>num_qubits</code> <code>Optional[int]</code> <p>Total number of qubits (inferred if not specified)</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>2^n \u00d7 2^n complex Hermitian matrix</p> Source code in <code>metalq/spin.py</code> <pre><code>def to_matrix(self, num_qubits: Optional[int] = None) -&gt; np.ndarray:\n    \"\"\"\n    Convert to full matrix representation.\n\n    Args:\n        num_qubits: Total number of qubits (inferred if not specified)\n\n    Returns:\n        2^n \u00d7 2^n complex Hermitian matrix\n    \"\"\"\n    if num_qubits is None:\n        num_qubits = self.num_qubits\n\n    if num_qubits == 0:\n        # Constant term only\n        const = sum(t.coeff for t in self._terms if not t.ops)\n        return np.array([[const]], dtype=np.complex128)\n\n    dim = 2 ** num_qubits\n    result = np.zeros((dim, dim), dtype=np.complex128)\n\n    for term in self._terms:\n        result += term.to_matrix(num_qubits)\n\n    return result\n</code></pre>"},{"location":"api/circuit/#metalq.Hamiltonian.to_sparse","title":"<code>to_sparse(num_qubits=None)</code>","text":"<p>Convert to sparse matrix representation.</p> <p>Returns:</p> Type Description <p>scipy.sparse matrix</p> Source code in <code>metalq/spin.py</code> <pre><code>def to_sparse(self, num_qubits: Optional[int] = None):\n    \"\"\"\n    Convert to sparse matrix representation.\n\n    Returns:\n        scipy.sparse matrix\n    \"\"\"\n    from scipy import sparse\n    return sparse.csr_matrix(self.to_matrix(num_qubits))\n</code></pre>"},{"location":"api/circuit/#metalq.PauliTerm.num_qubits","title":"<code>num_qubits</code>  <code>property</code>","text":"<p>Infer minimum number of qubits needed.</p>"},{"location":"api/circuit/#metalq.PauliTerm.qubits","title":"<code>qubits</code>  <code>property</code>","text":"<p>Get set of qubits this term acts on.</p>"},{"location":"api/circuit/#metalq.PauliTerm.__matmul__","title":"<code>__matmul__(other)</code>","text":"<p>Tensor product using @ operator.</p> Source code in <code>metalq/spin.py</code> <pre><code>def __matmul__(self, other: PauliTerm) -&gt; PauliTerm:\n    \"\"\"Tensor product using @ operator.\"\"\"\n    if isinstance(other, PauliTerm):\n        return PauliTerm(\n            self.coeff * other.coeff,\n            self.ops + other.ops\n        )\n    return NotImplemented\n</code></pre>"},{"location":"api/circuit/#metalq.PauliTerm.to_matrix","title":"<code>to_matrix(num_qubits=None)</code>","text":"<p>Convert to full matrix representation.</p> <p>Parameters:</p> Name Type Description Default <code>num_qubits</code> <code>Optional[int]</code> <p>Total number of qubits (inferred if not specified)</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>2^n \u00d7 2^n complex matrix</p> Source code in <code>metalq/spin.py</code> <pre><code>def to_matrix(self, num_qubits: Optional[int] = None) -&gt; np.ndarray:\n    \"\"\"\n    Convert to full matrix representation.\n\n    Args:\n        num_qubits: Total number of qubits (inferred if not specified)\n\n    Returns:\n        2^n \u00d7 2^n complex matrix\n    \"\"\"\n    if num_qubits is None:\n        num_qubits = self.num_qubits\n\n    if num_qubits == 0:\n        return np.array([[self.coeff]], dtype=np.complex128)\n\n    # Build operator dict\n    qubit_ops = {q: 'I' for q in range(num_qubits)}\n    for pauli, qubit in self.ops:\n        if qubit in qubit_ops:\n            # Multiply Paulis on same qubit\n            qubit_ops[qubit] = self._multiply_paulis(qubit_ops[qubit], pauli)\n        else:\n            qubit_ops[qubit] = pauli\n\n    # Tensor product\n    matrices = [_PAULI_MATRICES[qubit_ops[q]] for q in range(num_qubits)]\n\n    result = matrices[0]\n    for m in matrices[1:]:\n        result = np.kron(result, m)\n\n    return self.coeff * result\n</code></pre>"},{"location":"api/torch/","title":"Torch Integration","text":""},{"location":"api/torch/#quantumlayer","title":"QuantumLayer","text":"<p>               Bases: <code>Module</code></p> <p>A PyTorch layer representing a parameterized quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>The parameterized quantum circuit.</p> required <code>hamiltonian</code> <code>Hamiltonian</code> <p>The observable to measure.</p> required <code>backend_name</code> <code>str</code> <p>'mps' (default) or 'cpu'.</p> <code>'mps'</code> Source code in <code>metalq/torch/layer.py</code> <pre><code>class QuantumLayer(nn.Module):\n    \"\"\"\n    A PyTorch layer representing a parameterized quantum circuit.\n\n    Args:\n        circuit (Circuit): The parameterized quantum circuit.\n        hamiltonian (Hamiltonian): The observable to measure.\n        backend_name (str): 'mps' (default) or 'cpu'.\n    \"\"\"\n    def __init__(self, circuit: Circuit, hamiltonian: Hamiltonian, backend_name='mps'):\n        super().__init__()\n        self.circuit = circuit\n        self.hamiltonian = hamiltonian\n\n        # Initialize Backend\n        if backend_name == 'mps':\n            self.backend = MPSBackend()\n        else:\n            self.backend = CPUBackend()\n\n        # Use circuit.parameters to find all unique parameters\n        # This correctly handles parameters inside Expressions (recursion).\n        unique_params = circuit.parameters # List[Parameter]\n\n        self.param_names = [p.name for p in unique_params]\n        # self.params_ref = unique_params # Keep ref if needed? No, we rely on order.\n\n        init_values = []\n        for _ in unique_params:\n             init_values.append(torch.rand(1).item() * 6.28)\n\n        # Create trainable parameter tensor\n        self.weights = nn.Parameter(torch.tensor(init_values, dtype=torch.float32))\n\n    def forward(self, x=None):\n        \"\"\"\n        Forward pass.\n        args:\n            x: Input tensor (batch_size, input_dim). \n               Currently V1 supports scalar variational weights (simple optimization).\n               Data re-uploading (x input) requires mixing x with weights.\n\n               For V1 MVP optimization (VQE style): x is ignored or None.\n               Strictly optimizing Circuit parameters.\n        \"\"\"\n        # For simple optimization, we just use self.weights\n        # QuantumFunction expects (ctx, params, circuit, H, backend)\n\n        # Note: QuantumFunction.apply is how we call it.\n        # Call apply() on the class, passing context automatically handles arguments.\n        # Actually in Pytorch: Function.apply(input, *args)\n\n        exp_val = QuantumFunction.apply(self.weights, self.circuit, self.hamiltonian, self.backend)\n\n        return exp_val\n</code></pre>"},{"location":"api/torch/#metalq.torch.QuantumLayer.forward","title":"<code>forward(x=None)</code>","text":"<p>Forward pass. args:     x: Input tensor (batch_size, input_dim).         Currently V1 supports scalar variational weights (simple optimization).        Data re-uploading (x input) requires mixing x with weights.</p> <pre><code>   For V1 MVP optimization (VQE style): x is ignored or None.\n   Strictly optimizing Circuit parameters.\n</code></pre> Source code in <code>metalq/torch/layer.py</code> <pre><code>def forward(self, x=None):\n    \"\"\"\n    Forward pass.\n    args:\n        x: Input tensor (batch_size, input_dim). \n           Currently V1 supports scalar variational weights (simple optimization).\n           Data re-uploading (x input) requires mixing x with weights.\n\n           For V1 MVP optimization (VQE style): x is ignored or None.\n           Strictly optimizing Circuit parameters.\n    \"\"\"\n    # For simple optimization, we just use self.weights\n    # QuantumFunction expects (ctx, params, circuit, H, backend)\n\n    # Note: QuantumFunction.apply is how we call it.\n    # Call apply() on the class, passing context automatically handles arguments.\n    # Actually in Pytorch: Function.apply(input, *args)\n\n    exp_val = QuantumFunction.apply(self.weights, self.circuit, self.hamiltonian, self.backend)\n\n    return exp_val\n</code></pre>"},{"location":"api/torch/#quantumfunction","title":"QuantumFunction","text":"<p>               Bases: <code>Function</code></p> <p>Custom autograd function for variational quantum circuits. Forward: Calculates Expectation Value . Backward: Calculates Gradients via Adjoint Differentiation (or Parameter Shift). Source code in <code>metalq/torch/function.py</code> <pre><code>class QuantumFunction(torch.autograd.Function):\n    \"\"\"\n    Custom autograd function for variational quantum circuits.\n    Forward: Calculates Expectation Value &lt;H&gt;.\n    Backward: Calculates Gradients via Adjoint Differentiation (or Parameter Shift).\n    \"\"\"\n\n    @staticmethod\n    def forward(ctx, params_tensor, circuit, hamiltonian, backend):\n        \"\"\"\n        Args:\n            ctx: Context object to save info for backward.\n            params_tensor: Tensor of shape (n_params,) containing parameter values.\n            circuit: Metal-Q Circuit object (parameterized).\n            hamiltonian: Metal-Q Hamiltonian/PauliTerm.\n            backend: Initialized Metal-Q backend instance.\n        \"\"\"\n        # Save context for backward\n        ctx.circuit = circuit\n        ctx.hamiltonian = hamiltonian\n        ctx.backend = backend\n\n        # Convert tensor to list for backend\n        params_list = params_tensor.detach().numpy().tolist()\n        ctx.params_list = params_list\n\n        # Calculate Expectation\n        exp_val = backend.expectation(circuit, hamiltonian, params_list)\n\n        # Return as tensor\n        ctx.save_for_backward(params_tensor)\n        return torch.tensor(exp_val, dtype=params_tensor.dtype)\n\n    @staticmethod\n    def backward(ctx, grad_output):\n        \"\"\"\n        Backward pass using Adjoint Differentiation.\n        \"\"\"\n        params_tensor, = ctx.saved_tensors\n        circuit = ctx.circuit\n        hamiltonian = ctx.hamiltonian\n        backend = ctx.backend\n\n        # We need gradients w.r.t parameters\n        # Call backend.gradient\n        # If backend supports 'adjoint', it will be fast. \n        # Only MPS supports 'adjoint' currently.\n\n        method = 'adjoint' if backend.name == 'mps' else 'parameter_shift'\n\n        grads = backend.gradient(circuit, hamiltonian, ctx.params_list, method=method)\n\n        # Chain Rule Mapping (Gate Grads -&gt; Circuit Param Grads)\n        # backend.gradient returns flat array of gradients for every gate parameter.\n\n        unique_params = circuit.parameters\n        num_inputs = len(unique_params)\n        final_grads = np.zeros(num_inputs)\n\n        gate_ptr = 0\n        from ..parameter import Parameter, ParameterExpression\n\n        for gate in circuit.gates:\n            for p in gate.params:\n                # Backend gradient for this gate parameter\n                g_gate = grads[gate_ptr]\n                gate_ptr += 1\n\n                # Distribution to input parameters (Chain Rule)\n                # dL/dInput = dL/dGate * dGate/dInput\n\n                if isinstance(p, Parameter):\n                    # Direct parameter\n                    # Find index in unique_params (inefficient search? Map would be better)\n                    # Optimization: Create map once in Forward? \n                    # For MVP, linear scan or check.\n                    try:\n                        idx = unique_params.index(p)\n                        final_grads[idx] += g_gate\n                    except ValueError:\n                        pass # Parameter not in inputs?\n\n                elif isinstance(p, ParameterExpression):\n                    # Expression: dGate/dInput comes from p.grad(up)\n                    for i, up in enumerate(unique_params):\n                        scale = p.grad(up)\n                        if abs(scale) &gt; 1e-9:\n                            final_grads[i] += g_gate * scale\n\n        # Convert to tensor\n        grads_tensor = torch.from_numpy(final_grads).to(params_tensor.dtype)\n\n        # Chain rule: dL/dParam = dL/dExp * dExp/dParam\n        final_grad = grad_output * grads_tensor\n\n        # Return gradient for each input to forward. None for non-tensors.\n        return final_grad, None, None, None\n</code></pre>"},{"location":"api/torch/#metalq.torch.QuantumFunction.backward","title":"<code>backward(ctx, grad_output)</code>  <code>staticmethod</code>","text":"<p>Backward pass using Adjoint Differentiation.</p> Source code in <code>metalq/torch/function.py</code> <pre><code>@staticmethod\ndef backward(ctx, grad_output):\n    \"\"\"\n    Backward pass using Adjoint Differentiation.\n    \"\"\"\n    params_tensor, = ctx.saved_tensors\n    circuit = ctx.circuit\n    hamiltonian = ctx.hamiltonian\n    backend = ctx.backend\n\n    # We need gradients w.r.t parameters\n    # Call backend.gradient\n    # If backend supports 'adjoint', it will be fast. \n    # Only MPS supports 'adjoint' currently.\n\n    method = 'adjoint' if backend.name == 'mps' else 'parameter_shift'\n\n    grads = backend.gradient(circuit, hamiltonian, ctx.params_list, method=method)\n\n    # Chain Rule Mapping (Gate Grads -&gt; Circuit Param Grads)\n    # backend.gradient returns flat array of gradients for every gate parameter.\n\n    unique_params = circuit.parameters\n    num_inputs = len(unique_params)\n    final_grads = np.zeros(num_inputs)\n\n    gate_ptr = 0\n    from ..parameter import Parameter, ParameterExpression\n\n    for gate in circuit.gates:\n        for p in gate.params:\n            # Backend gradient for this gate parameter\n            g_gate = grads[gate_ptr]\n            gate_ptr += 1\n\n            # Distribution to input parameters (Chain Rule)\n            # dL/dInput = dL/dGate * dGate/dInput\n\n            if isinstance(p, Parameter):\n                # Direct parameter\n                # Find index in unique_params (inefficient search? Map would be better)\n                # Optimization: Create map once in Forward? \n                # For MVP, linear scan or check.\n                try:\n                    idx = unique_params.index(p)\n                    final_grads[idx] += g_gate\n                except ValueError:\n                    pass # Parameter not in inputs?\n\n            elif isinstance(p, ParameterExpression):\n                # Expression: dGate/dInput comes from p.grad(up)\n                for i, up in enumerate(unique_params):\n                    scale = p.grad(up)\n                    if abs(scale) &gt; 1e-9:\n                        final_grads[i] += g_gate * scale\n\n    # Convert to tensor\n    grads_tensor = torch.from_numpy(final_grads).to(params_tensor.dtype)\n\n    # Chain rule: dL/dParam = dL/dExp * dExp/dParam\n    final_grad = grad_output * grads_tensor\n\n    # Return gradient for each input to forward. None for non-tensors.\n    return final_grad, None, None, None\n</code></pre>"},{"location":"api/torch/#metalq.torch.QuantumFunction.forward","title":"<code>forward(ctx, params_tensor, circuit, hamiltonian, backend)</code>  <code>staticmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>ctx</code> <p>Context object to save info for backward.</p> required <code>params_tensor</code> <p>Tensor of shape (n_params,) containing parameter values.</p> required <code>circuit</code> <p>Metal-Q Circuit object (parameterized).</p> required <code>hamiltonian</code> <p>Metal-Q Hamiltonian/PauliTerm.</p> required <code>backend</code> <p>Initialized Metal-Q backend instance.</p> required Source code in <code>metalq/torch/function.py</code> <pre><code>@staticmethod\ndef forward(ctx, params_tensor, circuit, hamiltonian, backend):\n    \"\"\"\n    Args:\n        ctx: Context object to save info for backward.\n        params_tensor: Tensor of shape (n_params,) containing parameter values.\n        circuit: Metal-Q Circuit object (parameterized).\n        hamiltonian: Metal-Q Hamiltonian/PauliTerm.\n        backend: Initialized Metal-Q backend instance.\n    \"\"\"\n    # Save context for backward\n    ctx.circuit = circuit\n    ctx.hamiltonian = hamiltonian\n    ctx.backend = backend\n\n    # Convert tensor to list for backend\n    params_list = params_tensor.detach().numpy().tolist()\n    ctx.params_list = params_list\n\n    # Calculate Expectation\n    exp_val = backend.expectation(circuit, hamiltonian, params_list)\n\n    # Return as tensor\n    ctx.save_for_backward(params_tensor)\n    return torch.tensor(exp_val, dtype=params_tensor.dtype)\n</code></pre>"},{"location":"api/visualization/","title":"Visualization","text":"<p>Utilities for visualizing quantum circuits.</p>"},{"location":"api/visualization/#drawing","title":"Drawing","text":"Source code in <code>metalq/visualization.py</code> <pre><code>def draw_circuit(circuit: 'Circuit', output: str = 'text') -&gt; str:\n    if output == 'text':\n        drawer = TextDrawer(circuit)\n        return drawer.draw()\n    else:\n        return \"LaTeX not implemented\"\n</code></pre>"},{"location":"user_guide/algorithms/","title":"Algorithms","text":"<p>Metal-Q provides built-in implementations of popular quantum algorithms, leveraging the performance of the Metal backend.</p>"},{"location":"user_guide/algorithms/#vqe-variational-quantum-eigensolver","title":"VQE (Variational Quantum Eigensolver)","text":"<p>VQE is a hybrid algorithm used to find the ground state energy of a Hamiltonian.</p>"},{"location":"user_guide/algorithms/#example-h2-molecule","title":"Example: H2 Molecule","text":"<p>Here is a simplified example of finding the ground state energy for a Hydrogen molecule.</p> <pre><code>from metalq import Circuit, Parameter, Z, X, Hamiltonian\nfrom metalq.algorithms import VQE\nimport numpy as np\n\nprint(\"=== VQE: H2 Molecule (Simplified) ===\")\n\n# 1. Define Hamiltonian\n# H2 simplified 2-qubit mapping\nH = 0.39 * Z(0) + 0.39 * Z(1) + 0.18 * (Z(0) * Z(1)) + 0.01 * (X(0) * X(1))\nprint(f\"Hamiltonian terms: {len(H.terms)}\")\n\n# 2. Construct Ansatz (Hardware Efficient)\nqc = Circuit(2)\ntheta = [Parameter(f't{i}') for i in range(4)]\n\nqc.ry(theta[0], 0)\nqc.ry(theta[1], 1)\nqc.cx(0, 1)\nqc.ry(theta[2], 0)\nqc.ry(theta[3], 1)\n\nprint(\"Ansatz constructed.\")\n\n# 3. Run VQE\n# VQE init takes ansatz and optimizer options\nvqe = VQE(qc, optimizer_kwargs={'lr': 0.1})\n\nprint(\"\\nRunning VQE...\")\n# compute_minimum_eigenvalue takes hamiltonian\nresult = vqe.compute_minimum_eigenvalue(H, max_iter=50)\n\nprint(f\"Minimum Eigenvalue found: {result.eigenvalue:.6f}\")\nprint(f\"Optimal Parameters: {[f'{p:.4f}' for p in result.optimal_params]}\")\nprint(f\"Total offset (approx -1.05): {result.eigenvalue - 1.05:.6f} Ha\")\n</code></pre>"},{"location":"user_guide/algorithms/#output","title":"Output","text":"<pre><code>=== VQE: H2 Molecule (Simplified) ===\nHamiltonian terms: 4\nAnsatz constructed.\n\nRunning VQE...\nMinimum Eigenvalue found: -0.593803\nOptimal Parameters: ['-0.1563', '-2.0601', '3.2037', '0.4953']\nTotal offset (approx -1.05): -1.643803 Ha\n</code></pre>"},{"location":"user_guide/algorithms/#qaoa-quantum-approximate-optimization-algorithm","title":"QAOA (Quantum Approximate Optimization Algorithm)","text":"<p>QAOA is used for solving combinatorial optimization problems.</p>"},{"location":"user_guide/algorithms/#example-maxcut","title":"Example: MaxCut","text":"<p>Solving MaxCut on a simple triangle graph (3 nodes).</p> <pre><code>from metalq.algorithms import QAOA\nfrom metalq import Hamiltonian, Z, run\nimport networkx as nx\n\nprint(\"=== QAOA: MaxCut on Triangle Graph ===\")\n\n# 1. Define Graph &amp; Hamiltonian\n# Triangle (0-1, 1-2, 2-0)\nedges = [(0, 1), (1, 2), (2, 0)]\n\n# Cost Hamiltonian for MaxCut: H_C = 0.5 * sum_{i,j} (1 - Zi Zj)\n# Effectively minimize sum (Zi Zj) to maximize cuts\nH_cost = Hamiltonian()\nfor i, j in edges:\n    H_cost = H_cost + (Z(i) * Z(j))\n\nprint(f\"Graph Edges: {edges}\")\n\n# 2. Run QAOA\n# p (reps): Number of QAOA layers\nprint(\"Running QAOA (p=1)...\")\nqaoa = QAOA(H_cost, reps=1)\nresult = qaoa.compute(max_iter=30)\n\nprint(f\"Optimal Value (Energy): {result.eigenvalue:.4f}\")\n\n# 3. Get Solution\n# Bind optimal parameters to ansatz and measure\nqc_solved = qaoa.ansatz.bind_parameters(result.optimal_params)\nfinal_res = run(qc_solved, shots=1000)\nprint(f\"Measurement Counts: {final_res.counts}\")\n</code></pre>"},{"location":"user_guide/algorithms/#output_1","title":"Output","text":"<p><pre><code>=== QAOA: MaxCut on Triangle Graph ===\nGraph Edges: [(0, 1), (1, 2), (2, 0)]\nRunning QAOA (p=1)...\nOptimal Value (Energy): -0.9999\nMeasurement Counts: {'010': 184, '110': 171, '101': 151, '000': 1, '011': 158, '100': 163, '001': 172}\n</code></pre> Note: The most frequent bitstrings (010, 110, 101, etc.) correspond to cuts that separate the nodes, showing the optimal solution.</p>"},{"location":"user_guide/basics/","title":"Basics","text":"<p>This guide covers the fundamental usage of Metal-Q for quantum circuit simulation.</p>"},{"location":"user_guide/basics/#circuit-construction","title":"Circuit Construction","text":"<p>The core of Metal-Q is the <code>Circuit</code> class. It provides a familiar interface similar to other quantum frameworks.</p>"},{"location":"user_guide/basics/#creating-a-bell-state","title":"Creating a Bell State","text":"<pre><code>from metalq import Circuit\n\nprint(\"=== Basic Circuit Simulation ===\")\n\n# Create a Bell State circuit\nqc = Circuit(2)\nqc.h(0)        # Hadamard gate on qubit 0\nqc.cx(0, 1)    # CNOT gate (control 0, target 1)\n\nprint(\"Circuit created:\")\nprint(qc)\n</code></pre>"},{"location":"user_guide/basics/#output","title":"Output","text":"<pre><code>=== Basic Circuit Simulation ===\nCircuit created:\n     \u256d\u2500\u256e   \nq_0: \u2502H\u2502\u2500\u25cf\u2500\n     \u2570\u2500\u256f \u2502 \n        \u256d\u2534\u256e\nq_1: \u2500\u2500\u2500\u2502X\u2502\n        \u2570\u2500\u256f\n</code></pre>"},{"location":"user_guide/basics/#running-simulation","title":"Running Simulation","text":"<p>To simulate the circuit, use the <code>run</code> function. Metal-Q automatically selects the best available backend (MPS for Apple Silicon, CPU otherwise), but you can specify it manually.</p>"},{"location":"user_guide/basics/#mps-backend-apple-silicon-gpu","title":"MPS Backend (Apple Silicon GPU)","text":"<p>The default backend on macOS utilize Metal Performance Shaders for high-performance GPU simulation.</p> <pre><code>from metalq import run\n\n# Run on MPS\nprint(\"\\nRunning on MPS backend...\")\nresult = run(qc, shots=1000, backend='mps')\nprint(f\"Counts: {result.counts}\")\nprint(f\"Statevector (first 4 elements): {result.statevector[:4]}\")\n</code></pre>"},{"location":"user_guide/basics/#output_1","title":"Output","text":"<pre><code>Running on MPS backend...\nCounts: {'11': 501, '00': 499}\nStatevector (first 4 elements): [0.70710677+0.j 0.        +0.j 0.        +0.j 0.70710677+0.j]\n</code></pre>"},{"location":"user_guide/basics/#cpu-backend","title":"CPU Backend","text":"<p>Metal-Q also provides a high-performance CPU backend optimized with Numba and Polars.</p> <pre><code># Run on CPU\nprint(\"\\nRunning on CPU backend...\")\nresult_cpu = run(qc, shots=1000, backend='cpu')\nprint(f\"Counts (CPU): {result_cpu.counts}\")\n</code></pre>"},{"location":"user_guide/basics/#output_2","title":"Output","text":"<pre><code>Running on CPU backend...\nCounts (CPU): {'11': 491, '00': 509}\n</code></pre>"},{"location":"user_guide/basics/#qiskit-interoperability","title":"Qiskit Interoperability","text":"<p>Metal-Q provides seamless adapters to convert Qiskit circuits, allowing you to run existing Qiskit code on Apple Silicon GPUs.</p> <pre><code>from qiskit import QuantumCircuit\nfrom metalq.adapters import to_metalq, to_qiskit\nfrom metalq import run\n\nprint(\"=== Qiskit Interoperability ===\")\n\n# 1. Create Qiskit Circuit\nqc_qiskit = QuantumCircuit(2)\nqc_qiskit.h(0)\nqc_qiskit.cx(0, 1)\nqc_qiskit.rz(0.5, 1)\nprint(\"Qiskit Circuit created.\")\n\n# 2. Convert to Metal-Q\nprint(\"\\nConverting to Metal-Q...\")\nqc_metalq = to_metalq(qc_qiskit)\nprint(f\"Metal-Q Circuit:\\n{qc_metalq}\")\n\n# 3. Run on Metal-Q\nprint(\"\\nRunning on Metal-Q MPS backend...\")\nresult = run(qc_metalq, shots=100)\nprint(f\"Counts: {result.counts}\")\n\n# 4. Convert back to Qiskit\nprint(\"\\nConverting back to Qiskit...\")\nqc_back = to_qiskit(qc_metalq)\nprint(\"Conversion successful.\")\nprint(qc_back)\n</code></pre>"},{"location":"user_guide/basics/#output_3","title":"Output","text":"<pre><code>=== Qiskit Interoperability ===\nQiskit Circuit created.\n\nConverting to Metal-Q...\nMetal-Q Circuit:\n     \u256d\u2500\u256e              \nq_0: \u2502H\u2502\u2500\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     \u2570\u2500\u256f \u2502            \n        \u256d\u2534\u256e\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \nq_1: \u2500\u2500\u2500\u2502X\u2502\u2502RZ(0.50)\u2502\u2500\n        \u2570\u2500\u256f\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \n\nRunning on Metal-Q MPS backend...\nCounts: {'00': 54, '11': 46}\n\nConverting back to Qiskit...\nConversion successful.\n     \u250c\u2500\u2500\u2500\u2510                \nq_0: \u2524 H \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nq_1: \u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 Rz(0.5) \u251c\n          \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"user_guide/pytorch/","title":"PyTorch Integration","text":"<p>Metal-Q uniquely integrates with PyTorch, allowing quantum circuits to be used as differentiable layers within neural networks (<code>nn.Module</code>). This enables hybrid quantum-classical machine learning (QML) on GPUs.</p>"},{"location":"user_guide/pytorch/#quantum-layer","title":"Quantum Layer","text":"<p>The <code>QuantumLayer</code> class wraps a parameterized <code>Circuit</code> and an observable (<code>Hamiltonian</code>) into a PyTorch module. It automatically computes gradients using the Adjoint Differentiation method (or Parameter Shift rule on CPU).</p>"},{"location":"user_guide/pytorch/#example-simple-optimization","title":"Example: Simple Optimization","text":"<p>In this example, we optimize a single parameter to minimize the expectation value of an observable.</p> <pre><code>import torch\nimport torch.optim as optim\nfrom metalq import Circuit, Parameter, Z\nfrom metalq.torch import QuantumLayer\n\nprint(\"=== PyTorch Integration: Simple Optimization ===\")\n\n# 1. Define Hamiltonian: H = Z0\nH = Z(0)\n\n# 2. Define Circuit with 1 parameter\nqc = Circuit(1)\ntheta = Parameter('theta')\nqc.rx(theta, 0)\n\n# 3. Create Quantum Layer\n#    Input: None (handled internally or via batch inputs)\n#    Output: Expectation value &lt;Z0&gt;\nmodel = QuantumLayer(qc, H, backend_name='mps')\noptimizer = optim.Adam(model.parameters(), lr=0.1)\n\n# Initial parameter\nprint(f\"Initial param: {list(model.parameters())[0].item():.4f}\")\n\n# 4. Optimization Loop\nprint(\"\\nStarting optimization (Target: Minimize &lt;Z0&gt; -&gt; |1&gt; state)...\")\nfor i in range(21):\n    optimizer.zero_grad()\n    loss = model()     # Forward pass\n    loss.backward()    # Backward pass (Adjoint Differentiation)\n    optimizer.step()\n\n    if i % 5 == 0:\n        print(f\"Step {i}: Loss = {loss.item():.4f}, Param = {list(model.parameters())[0].item():.4f}\")\n\nprint(\"\\nOptimization complete.\")\n</code></pre>"},{"location":"user_guide/pytorch/#output","title":"Output","text":"<pre><code>=== PyTorch Integration: Simple Optimization ===\nInitial param: 3.8440\n\nStarting optimization (Target: Minimize &lt;Z0&gt; -&gt; |1&gt; state)...\nStep 0: Loss = -0.7633, Param = 3.7440\nStep 5: Loss = -0.9770, Param = 3.2677\nStep 10: Loss = -0.9887, Param = 2.9500\nStep 15: Loss = -0.9720, Param = 2.9180\nStep 20: Loss = -0.9937, Param = 3.0641\n\nOptimization complete.\n</code></pre>"},{"location":"user_guide/pytorch/#creating-hybrid-models","title":"Creating Hybrid Models","text":"<p>You can combine <code>QuantumLayer</code> with standard PyTorch layers (<code>nn.Linear</code>, <code>nn.Conv2d</code>, etc.) to build hybrid models.</p> <pre><code>import torch.nn as nn\n\nclass HybridModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.classical_pre = nn.Linear(4, 2)\n        self.quantum = QuantumLayer(qc, H)\n        self.classical_post = nn.Linear(1, 1)\n\n    def forward(self, x):\n        x = self.classical_pre(x)\n        x = torch.sigmoid(x)\n        # Note: QuantumLayer currently might need adaptation for batch inputs\n        # typical usage involves mapping classical features to rotation angles\n        x_q = self.quantum(inputs={theta: x}) \n        return self.classical_post(x_q)\n</code></pre>"}]}